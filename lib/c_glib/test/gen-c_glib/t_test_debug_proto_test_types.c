/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include "t_test_debug_proto_test_types.h"
#include <thrift/c_glib/thrift.h>

/* reads a doubles object */
static gint32
t_test_doubles_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestDoubles * this_object = T_TEST_DOUBLES(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->nan, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_nan = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->inf, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_inf = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->neginf, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_neginf = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->repeating, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_repeating = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->big, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_big = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->small, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_small = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->zero, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_zero = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->negzero, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_negzero = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_doubles_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestDoubles * this_object = T_TEST_DOUBLES(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Doubles", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "nan", T_DOUBLE, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->nan, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "inf", T_DOUBLE, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->inf, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "neginf", T_DOUBLE, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->neginf, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "repeating", T_DOUBLE, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->repeating, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "big", T_DOUBLE, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->big, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "small", T_DOUBLE, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->small, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "zero", T_DOUBLE, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->zero, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "negzero", T_DOUBLE, 8, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->negzero, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_doubles_instance_init (TTestDoubles * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->nan = 0;
  object->__isset_nan = FALSE;
  object->inf = 0;
  object->__isset_inf = FALSE;
  object->neginf = 0;
  object->__isset_neginf = FALSE;
  object->repeating = 0;
  object->__isset_repeating = FALSE;
  object->big = 0;
  object->__isset_big = FALSE;
  object->small = 0;
  object->__isset_small = FALSE;
  object->zero = 0;
  object->__isset_zero = FALSE;
  object->negzero = 0;
  object->__isset_negzero = FALSE;
}

static void 
t_test_doubles_finalize (GObject *object)
{
  TTestDoubles *tobject = T_TEST_DOUBLES (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void 
t_test_doubles_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_doubles_finalize;
  cls->read = t_test_doubles_read;
  cls->write = t_test_doubles_write;
}

GType
t_test_doubles_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestDoublesClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_doubles_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestDoubles),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_doubles_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestDoublesType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a one_of_each object */
static gint32
t_test_one_of_each_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestOneOfEach * this_object = T_TEST_ONE_OF_EACH(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->im_true, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_im_true = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->im_false, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_im_false = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->a_bite, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_a_bite = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->integer16, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_integer16 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->integer32, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_integer32 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->integer64, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_integer64 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->double_precision, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_double_precision = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRING)
        {
          if (this_object->some_characters != NULL)
          {
            g_free(this_object->some_characters);
            this_object->some_characters = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->some_characters, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_some_characters = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_STRING)
        {
          if (this_object->zomg_unicode != NULL)
          {
            g_free(this_object->zomg_unicode);
            this_object->zomg_unicode = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->zomg_unicode, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_zomg_unicode = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->what_who, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_what_who = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_STRING)
        {
          if (this_object->base64 != NULL)
          {
            g_free(this_object->base64);
            this_object->base64 = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->base64 = g_byte_array_new();
          g_byte_array_append (this_object->base64, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_base64 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint8* _elem0 = g_new (gint8, 1);
              if ((ret = thrift_protocol_read_byte (protocol, &*_elem0, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->byte_list, _elem0, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_byte_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 13:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint16* _elem1 = g_new (gint16, 1);
              if ((ret = thrift_protocol_read_i16 (protocol, &*_elem1, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->i16_list, _elem1, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_i16_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 14:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint64* _elem2 = g_new (gint64, 1);
              if ((ret = thrift_protocol_read_i64 (protocol, &*_elem2, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->i64_list, _elem2, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_i64_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_one_of_each_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestOneOfEach * this_object = T_TEST_ONE_OF_EACH(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "OneOfEach", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "im_true", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->im_true, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "im_false", T_BOOL, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->im_false, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "a_bite", T_BYTE, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->a_bite, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "integer16", T_I16, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->integer16, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "integer32", T_I32, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->integer32, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "integer64", T_I64, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->integer64, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "double_precision", T_DOUBLE, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->double_precision, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "some_characters", T_STRING, 8, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->some_characters, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "zomg_unicode", T_STRING, 9, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->zomg_unicode, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "what_who", T_BOOL, 10, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->what_who, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "base64", T_STRING, 11, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->base64)->data, ((GByteArray *) this_object->base64)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_list", T_LIST, 12, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_BYTE, (gint32) this_object->byte_list->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i3;
    for (i3=0; i3<this_object->byte_list->len; i3++)
    {
      if ((ret = thrift_protocol_write_byte (protocol, (g_array_index (this_object->byte_list, gint8, i3)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i16_list", T_LIST, 13, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_I16, (gint32) this_object->i16_list->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i4;
    for (i4=0; i4<this_object->i16_list->len; i4++)
    {
      if ((ret = thrift_protocol_write_i16 (protocol, (g_array_index (this_object->i16_list, gint16, i4)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i64_list", T_LIST, 14, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_I64, (gint32) this_object->i64_list->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i5;
    for (i5=0; i5<this_object->i64_list->len; i5++)
    {
      if ((ret = thrift_protocol_write_i64 (protocol, (g_array_index (this_object->i64_list, gint64, i5)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_one_of_each_instance_init (TTestOneOfEach * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->im_true = 0;
  object->__isset_im_true = FALSE;
  object->im_false = 0;
  object->__isset_im_false = FALSE;
  object->a_bite = 127;
  object->__isset_a_bite = FALSE;
  object->integer16 = 32767;
  object->__isset_integer16 = FALSE;
  object->integer32 = 0;
  object->__isset_integer32 = FALSE;
  object->integer64 = 10000000000;
  object->__isset_integer64 = FALSE;
  object->double_precision = 0;
  object->__isset_double_precision = FALSE;
  object->some_characters = NULL;
  object->__isset_some_characters = FALSE;
  object->zomg_unicode = NULL;
  object->__isset_zomg_unicode = FALSE;
  object->what_who = 0;
  object->__isset_what_who = FALSE;
  object->base64 = NULL;
  object->__isset_base64 = FALSE;
  object->byte_list = g_array_new (0, 1, sizeof (gint8));
  object->__isset_byte_list = FALSE;
  object->i16_list = g_array_new (0, 1, sizeof (gint16));
  object->__isset_i16_list = FALSE;
  object->i64_list = g_array_new (0, 1, sizeof (gint64));
  object->__isset_i64_list = FALSE;
}

static void 
t_test_one_of_each_finalize (GObject *object)
{
  TTestOneOfEach *tobject = T_TEST_ONE_OF_EACH (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->some_characters != NULL)
  {
    g_free (tobject->some_characters);
    tobject->some_characters = NULL;
  }
  if (tobject->zomg_unicode != NULL)
  {
    g_free (tobject->zomg_unicode);
    tobject->zomg_unicode = NULL;
  }
  if (tobject->base64 != NULL)
  {
    g_free (tobject->base64);
    tobject->base64 = NULL;
  }
  if (tobject->byte_list != NULL)
  {
    g_array_free (tobject->byte_list, TRUE);
    tobject->byte_list = NULL;
  }
  if (tobject->i16_list != NULL)
  {
    g_array_free (tobject->i16_list, TRUE);
    tobject->i16_list = NULL;
  }
  if (tobject->i64_list != NULL)
  {
    g_array_free (tobject->i64_list, TRUE);
    tobject->i64_list = NULL;
  }
}

static void 
t_test_one_of_each_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_one_of_each_finalize;
  cls->read = t_test_one_of_each_read;
  cls->write = t_test_one_of_each_write;
}

GType
t_test_one_of_each_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestOneOfEachClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_one_of_each_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestOneOfEach),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_one_of_each_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestOneOfEachType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a bonk object */
static gint32
t_test_bonk_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestBonk * this_object = T_TEST_BONK(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->type, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->message != NULL)
          {
            g_free(this_object->message);
            this_object->message = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->message, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_message = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_bonk_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestBonk * this_object = T_TEST_BONK(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Bonk", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->type, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->message, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_bonk_instance_init (TTestBonk * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->type = 0;
  object->__isset_type = FALSE;
  object->message = NULL;
  object->__isset_message = FALSE;
}

static void 
t_test_bonk_finalize (GObject *object)
{
  TTestBonk *tobject = T_TEST_BONK (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->message != NULL)
  {
    g_free (tobject->message);
    tobject->message = NULL;
  }
}

static void 
t_test_bonk_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_bonk_finalize;
  cls->read = t_test_bonk_read;
  cls->write = t_test_bonk_write;
}

GType
t_test_bonk_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestBonkClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_bonk_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestBonk),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_bonk_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestBonkType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a nesting object */
static gint32
t_test_nesting_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestNesting * this_object = T_TEST_NESTING(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->my_bonk), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_my_bonk = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->my_ooe), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_my_ooe = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_nesting_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestNesting * this_object = T_TEST_NESTING(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Nesting", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "my_bonk", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->my_bonk), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "my_ooe", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->my_ooe), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_nesting_instance_init (TTestNesting * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->my_bonk = g_object_new (T_TEST_TYPE_BONK, NULL);
  object->__isset_my_bonk = FALSE;
  object->my_ooe = g_object_new (T_TEST_TYPE_ONE_OF_EACH, NULL);
  object->__isset_my_ooe = FALSE;
}

static void 
t_test_nesting_finalize (GObject *object)
{
  TTestNesting *tobject = T_TEST_NESTING (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->my_bonk != NULL)
  {
    g_object_unref(tobject->my_bonk);
    tobject->my_bonk = NULL;
  }
  if (tobject->my_ooe != NULL)
  {
    g_object_unref(tobject->my_ooe);
    tobject->my_ooe = NULL;
  }
}

static void 
t_test_nesting_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_nesting_finalize;
  cls->read = t_test_nesting_read;
  cls->write = t_test_nesting_write;
}

GType
t_test_nesting_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestNestingClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_nesting_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestNesting),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_nesting_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestNestingType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a holy_moley object */
static gint32
t_test_holy_moley_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestHolyMoley * this_object = T_TEST_HOLY_MOLEY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              TTestOneOfEach * _elem6 = NULL;
              if ( _elem6 != NULL)
              {
                g_object_unref (_elem6);
              }
              _elem6 = g_object_new (T_TEST_TYPE_ONE_OF_EACH, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem6), protocol, error)) < 0)
              {
                g_object_unref (_elem6);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->big, _elem6);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_big = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            guint32 i;
            for (i = 0; i < size; ++i)
            {
              GPtrArray * _elem7 = NULL;
              {
                guint32 size;
                ThriftType element_type;
                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                guint32 i;
                for (i = 0; i < size; i++)
                {
                  gchar * _elem8 = NULL;
                  if (_elem8 != NULL)
                  {
                    g_free(_elem8);
                    _elem8 = NULL;
                  }

                  if ((ret = thrift_protocol_read_string (protocol, &_elem8, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_ptr_array_add (_elem7, _elem8);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;

              }
              g_hash_table_insert ((GHashTable *) this_object->contain, (gpointer) _elem7, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_contain = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gchar * key9 = NULL;
              GPtrArray * val10 = NULL;
              if (key9 != NULL)
              {
                g_free(key9);
                key9 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key9, error)) < 0)
                return -1;
              xfer += ret;
              {
                guint32 size;
                ThriftType element_type;
                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                guint32 i;
                for (i = 0; i < size; i++)
                {
                  TTestBonk * _elem11 = NULL;
                  if ( _elem11 != NULL)
                  {
                    g_object_unref (_elem11);
                  }
                  _elem11 = g_object_new (T_TEST_TYPE_BONK, NULL);
                  if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem11), protocol, error)) < 0)
                  {
                    g_object_unref (_elem11);
                    return -1;
                  }
                  xfer += ret;
                  g_ptr_array_add (val10, _elem11);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;

              }
              g_hash_table_insert ((GHashTable *)this_object->bonks, (gpointer) key9, (gpointer) val10);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_bonks = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_holy_moley_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestHolyMoley * this_object = T_TEST_HOLY_MOLEY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HolyMoley", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "big", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->big->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i12;
    for (i12=0; i12<this_object->big->len; i12++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->big, i12))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "contain", T_SET, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_set_begin (protocol, T_LIST, (gint32) g_hash_table_size ((GHashTable *) this_object->contain), error)) < 0)
      return -1;
    xfer += ret;
    GList *key_list = NULL, *iter = NULL;
    GPtrArray * elem;
    gpointer value;
    THRIFT_UNUSED_VAR (value);

    g_hash_table_foreach ((GHashTable *) this_object->contain, thrift_hash_table_get_keys, &key_list);
    GPtrArray * keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (GPtrArray *) iter->data;
    }
    g_list_free (key_list);

    for (i=0; i<key_count; ++i)
    {
      elem = keys[i];
      value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->contain), (gpointer) elem);

      {
        if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) elem->len, error)) < 0)
          return -1;
        xfer += ret;
        guint i13;
        for (i13=0; i13<elem->len; i13++)
        {
          if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) elem, i13)), error)) < 0)
            return -1;
        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "bonks", T_MAP, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_LIST, (gint32) g_hash_table_size ((GHashTable *) this_object->bonks), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gchar * key;
    GPtrArray * value;
    g_hash_table_foreach ((GHashTable *) this_object->bonks, thrift_hash_table_get_keys, &key_list);
    gchar * keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gchar *) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (GPtrArray *) g_hash_table_lookup (((GHashTable *) this_object->bonks), (gpointer) key);

      if ((ret = thrift_protocol_write_string (protocol,  key, error)) < 0)
        return -1;
      {
        if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32)  value->len, error)) < 0)
          return -1;
        xfer += ret;
        guint i14;
        for (i14=0; i14< value->len; i14++)
        {
          if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *)  value, i14))), protocol, error)) < 0)
            return -1;
          xfer += ret;

        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_holy_moley_instance_init (TTestHolyMoley * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->big = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_big = FALSE;
  object->contain = g_hash_table_new_full (g_direct_hash, g_direct_equal, (GDestroyNotify) g_ptr_array_unref, NULL);
  object->__isset_contain = FALSE;
  object->bonks = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, (GDestroyNotify) g_ptr_array_unref);
  object->__isset_bonks = FALSE;
}

static void 
t_test_holy_moley_finalize (GObject *object)
{
  TTestHolyMoley *tobject = T_TEST_HOLY_MOLEY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->big != NULL)
  {
    g_ptr_array_free (tobject->big, TRUE);
    tobject->big = NULL;
  }
  if (tobject->contain != NULL)
  {
    g_hash_table_destroy (tobject->contain);
    tobject->contain = NULL;
  }
  if (tobject->bonks != NULL)
  {
    g_hash_table_destroy (tobject->bonks);
    tobject->bonks = NULL;
  }
}

static void 
t_test_holy_moley_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_holy_moley_finalize;
  cls->read = t_test_holy_moley_read;
  cls->write = t_test_holy_moley_write;
}

GType
t_test_holy_moley_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestHolyMoleyClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_holy_moley_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestHolyMoley),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_holy_moley_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestHolyMoleyType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a backwards object */
static gint32
t_test_backwards_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestBackwards * this_object = T_TEST_BACKWARDS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->first_tag2, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_first_tag2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->second_tag1, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_second_tag1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_backwards_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestBackwards * this_object = T_TEST_BACKWARDS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Backwards", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "first_tag2", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->first_tag2, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "second_tag1", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->second_tag1, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_backwards_instance_init (TTestBackwards * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->first_tag2 = 0;
  object->__isset_first_tag2 = FALSE;
  object->second_tag1 = 0;
  object->__isset_second_tag1 = FALSE;
}

static void 
t_test_backwards_finalize (GObject *object)
{
  TTestBackwards *tobject = T_TEST_BACKWARDS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void 
t_test_backwards_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_backwards_finalize;
  cls->read = t_test_backwards_read;
  cls->write = t_test_backwards_write;
}

GType
t_test_backwards_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestBackwardsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_backwards_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestBackwards),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_backwards_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestBackwardsType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a empty object */
static gint32
t_test_empty_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestEmpty * this_object = T_TEST_EMPTY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_empty_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestEmpty * this_object = T_TEST_EMPTY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Empty", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_empty_instance_init (TTestEmpty * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
t_test_empty_finalize (GObject *object)
{
  TTestEmpty *tobject = T_TEST_EMPTY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void 
t_test_empty_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_empty_finalize;
  cls->read = t_test_empty_read;
  cls->write = t_test_empty_write;
}

GType
t_test_empty_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestEmptyClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_empty_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestEmpty),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_empty_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestEmptyType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a wrapper object */
static gint32
t_test_wrapper_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestWrapper * this_object = T_TEST_WRAPPER(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->foo), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_foo = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_wrapper_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestWrapper * this_object = T_TEST_WRAPPER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Wrapper", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "foo", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->foo), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_wrapper_instance_init (TTestWrapper * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->foo = g_object_new (T_TEST_TYPE_EMPTY, NULL);
  object->__isset_foo = FALSE;
}

static void 
t_test_wrapper_finalize (GObject *object)
{
  TTestWrapper *tobject = T_TEST_WRAPPER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->foo != NULL)
  {
    g_object_unref(tobject->foo);
    tobject->foo = NULL;
  }
}

static void 
t_test_wrapper_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_wrapper_finalize;
  cls->read = t_test_wrapper_read;
  cls->write = t_test_wrapper_write;
}

GType
t_test_wrapper_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestWrapperClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_wrapper_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestWrapper),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_wrapper_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestWrapperType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a random_stuff object */
static gint32
t_test_random_stuff_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestRandomStuff * this_object = T_TEST_RANDOM_STUFF(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->a, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_a = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->b, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_b = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->c, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_c = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->d, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_d = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint32* _elem15 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem15, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->myintlist, _elem15, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_myintlist = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint32* key16 = g_new (gint32, 1);
              TTestWrapper * val17 = NULL;
              if ((ret = thrift_protocol_read_i32 (protocol, &*key16, error)) < 0)
                return -1;
              xfer += ret;
              if ( val17 != NULL)
              {
                g_object_unref (val17);
              }
              val17 = g_object_new (T_TEST_TYPE_WRAPPER, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (val17), protocol, error)) < 0)
              {
                g_object_unref (val17);
                return -1;
              }
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->maps, (gpointer) key16, (gpointer) val17);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_maps = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->bigint, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_bigint = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->triple, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_triple = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_random_stuff_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestRandomStuff * this_object = T_TEST_RANDOM_STUFF(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RandomStuff", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "a", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->a, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "b", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->b, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "c", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->c, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "d", T_I32, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->d, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "myintlist", T_LIST, 5, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) this_object->myintlist->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i18;
    for (i18=0; i18<this_object->myintlist->len; i18++)
    {
      if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->myintlist, gint32, i18)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "maps", T_MAP, 6, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_STRUCT, (gint32) g_hash_table_size ((GHashTable *) this_object->maps), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gint32* key;
    TTestWrapper * value;
    g_hash_table_foreach ((GHashTable *) this_object->maps, thrift_hash_table_get_keys, &key_list);
    gint32* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gint32*) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (TTestWrapper *) g_hash_table_lookup (((GHashTable *) this_object->maps), (gpointer) key);

      if ((ret = thrift_protocol_write_i32 (protocol, * key, error)) < 0)
        return -1;
      if ((ret = thrift_struct_write (THRIFT_STRUCT ( value), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "bigint", T_I64, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->bigint, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "triple", T_DOUBLE, 8, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->triple, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_random_stuff_instance_init (TTestRandomStuff * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->a = 0;
  object->__isset_a = FALSE;
  object->b = 0;
  object->__isset_b = FALSE;
  object->c = 0;
  object->__isset_c = FALSE;
  object->d = 0;
  object->__isset_d = FALSE;
  object->myintlist = g_array_new (0, 1, sizeof (gint32));
  object->__isset_myintlist = FALSE;
  object->maps = g_hash_table_new_full (g_int_hash, g_int_equal, NULL, g_object_unref);
  object->__isset_maps = FALSE;
  object->bigint = 0;
  object->__isset_bigint = FALSE;
  object->triple = 0;
  object->__isset_triple = FALSE;
}

static void 
t_test_random_stuff_finalize (GObject *object)
{
  TTestRandomStuff *tobject = T_TEST_RANDOM_STUFF (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->myintlist != NULL)
  {
    g_array_free (tobject->myintlist, TRUE);
    tobject->myintlist = NULL;
  }
  if (tobject->maps != NULL)
  {
    g_hash_table_destroy (tobject->maps);
    tobject->maps = NULL;
  }
}

static void 
t_test_random_stuff_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_random_stuff_finalize;
  cls->read = t_test_random_stuff_read;
  cls->write = t_test_random_stuff_write;
}

GType
t_test_random_stuff_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestRandomStuffClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_random_stuff_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestRandomStuff),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_random_stuff_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestRandomStuffType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a base64 object */
static gint32
t_test_base64_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestBase64 * this_object = T_TEST_BASE64(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->a, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_a = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->b1 != NULL)
          {
            g_free(this_object->b1);
            this_object->b1 = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->b1 = g_byte_array_new();
          g_byte_array_append (this_object->b1, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_b1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->b2 != NULL)
          {
            g_free(this_object->b2);
            this_object->b2 = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->b2 = g_byte_array_new();
          g_byte_array_append (this_object->b2, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_b2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->b3 != NULL)
          {
            g_free(this_object->b3);
            this_object->b3 = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->b3 = g_byte_array_new();
          g_byte_array_append (this_object->b3, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_b3 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->b4 != NULL)
          {
            g_free(this_object->b4);
            this_object->b4 = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->b4 = g_byte_array_new();
          g_byte_array_append (this_object->b4, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_b4 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->b5 != NULL)
          {
            g_free(this_object->b5);
            this_object->b5 = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->b5 = g_byte_array_new();
          g_byte_array_append (this_object->b5, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_b5 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRING)
        {
          if (this_object->b6 != NULL)
          {
            g_free(this_object->b6);
            this_object->b6 = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->b6 = g_byte_array_new();
          g_byte_array_append (this_object->b6, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_b6 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_base64_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestBase64 * this_object = T_TEST_BASE64(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Base64", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "a", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->a, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "b1", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->b1)->data, ((GByteArray *) this_object->b1)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "b2", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->b2)->data, ((GByteArray *) this_object->b2)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "b3", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->b3)->data, ((GByteArray *) this_object->b3)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "b4", T_STRING, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->b4)->data, ((GByteArray *) this_object->b4)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "b5", T_STRING, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->b5)->data, ((GByteArray *) this_object->b5)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "b6", T_STRING, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->b6)->data, ((GByteArray *) this_object->b6)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_base64_instance_init (TTestBase64 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->a = 0;
  object->__isset_a = FALSE;
  object->b1 = NULL;
  object->__isset_b1 = FALSE;
  object->b2 = NULL;
  object->__isset_b2 = FALSE;
  object->b3 = NULL;
  object->__isset_b3 = FALSE;
  object->b4 = NULL;
  object->__isset_b4 = FALSE;
  object->b5 = NULL;
  object->__isset_b5 = FALSE;
  object->b6 = NULL;
  object->__isset_b6 = FALSE;
}

static void 
t_test_base64_finalize (GObject *object)
{
  TTestBase64 *tobject = T_TEST_BASE64 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->b1 != NULL)
  {
    g_free (tobject->b1);
    tobject->b1 = NULL;
  }
  if (tobject->b2 != NULL)
  {
    g_free (tobject->b2);
    tobject->b2 = NULL;
  }
  if (tobject->b3 != NULL)
  {
    g_free (tobject->b3);
    tobject->b3 = NULL;
  }
  if (tobject->b4 != NULL)
  {
    g_free (tobject->b4);
    tobject->b4 = NULL;
  }
  if (tobject->b5 != NULL)
  {
    g_free (tobject->b5);
    tobject->b5 = NULL;
  }
  if (tobject->b6 != NULL)
  {
    g_free (tobject->b6);
    tobject->b6 = NULL;
  }
}

static void 
t_test_base64_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_base64_finalize;
  cls->read = t_test_base64_read;
  cls->write = t_test_base64_write;
}

GType
t_test_base64_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestBase64Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_base64_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestBase64),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_base64_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestBase64Type",
                                   &type_info, 0);
  }

  return type;
}

/* reads a compact_proto_test_struct object */
static gint32
t_test_compact_proto_test_struct_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestCompactProtoTestStruct * this_object = T_TEST_COMPACT_PROTO_TEST_STRUCT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->a_byte, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_a_byte = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->a_i16, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_a_i16 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->a_i32, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_a_i32 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->a_i64, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_a_i64 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->a_double, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_a_double = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->a_string != NULL)
          {
            g_free(this_object->a_string);
            this_object->a_string = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->a_string, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_a_string = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRING)
        {
          if (this_object->a_binary != NULL)
          {
            g_free(this_object->a_binary);
            this_object->a_binary = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->a_binary = g_byte_array_new();
          g_byte_array_append (this_object->a_binary, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_a_binary = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->true_field, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_true_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->false_field, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_false_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->empty_struct_field), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_empty_struct_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint8* _elem19 = g_new (gint8, 1);
              if ((ret = thrift_protocol_read_byte (protocol, &*_elem19, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->byte_list, _elem19, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_byte_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint16* _elem20 = g_new (gint16, 1);
              if ((ret = thrift_protocol_read_i16 (protocol, &*_elem20, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->i16_list, _elem20, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_i16_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 13:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint32* _elem21 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem21, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->i32_list, _elem21, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_i32_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 14:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint64* _elem22 = g_new (gint64, 1);
              if ((ret = thrift_protocol_read_i64 (protocol, &*_elem22, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->i64_list, _elem22, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_i64_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 15:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gdouble* _elem23 = g_new (gdouble, 1);
              if ((ret = thrift_protocol_read_double (protocol, &*_elem23, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->double_list, _elem23, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_double_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 16:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gchar * _elem24 = NULL;
              if (_elem24 != NULL)
              {
                g_free(_elem24);
                _elem24 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem24, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->string_list, _elem24);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_string_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 17:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem25 = NULL;
              if (_elem25 != NULL)
              {
                g_free(_elem25);
                _elem25 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem25 = g_byte_array_new();
              g_byte_array_append (_elem25, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->binary_list, _elem25);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_binary_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 18:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gboolean* _elem26 = g_new (gboolean, 1);
              if ((ret = thrift_protocol_read_bool (protocol, &*_elem26, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->boolean_list, _elem26, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_boolean_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 19:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              TTestEmpty * _elem27 = NULL;
              if ( _elem27 != NULL)
              {
                g_object_unref (_elem27);
              }
              _elem27 = g_object_new (T_TEST_TYPE_EMPTY, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem27), protocol, error)) < 0)
              {
                g_object_unref (_elem27);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->struct_list, _elem27);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_struct_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 20:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            guint32 i;
            for (i = 0; i < size; ++i)
            {
              gint8* _elem28 = g_new (gint8, 1);
              if ((ret = thrift_protocol_read_byte (protocol, &*_elem28, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *) this_object->byte_set, (gpointer) _elem28, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_byte_set = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 21:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            guint32 i;
            for (i = 0; i < size; ++i)
            {
              gint16* _elem29 = g_new (gint16, 1);
              if ((ret = thrift_protocol_read_i16 (protocol, &*_elem29, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *) this_object->i16_set, (gpointer) _elem29, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_i16_set = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 22:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            guint32 i;
            for (i = 0; i < size; ++i)
            {
              gint32* _elem30 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem30, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *) this_object->i32_set, (gpointer) _elem30, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_i32_set = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 23:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            guint32 i;
            for (i = 0; i < size; ++i)
            {
              gint64* _elem31 = g_new (gint64, 1);
              if ((ret = thrift_protocol_read_i64 (protocol, &*_elem31, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *) this_object->i64_set, (gpointer) _elem31, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_i64_set = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 24:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            guint32 i;
            for (i = 0; i < size; ++i)
            {
              gdouble* _elem32 = g_new (gdouble, 1);
              if ((ret = thrift_protocol_read_double (protocol, &*_elem32, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *) this_object->double_set, (gpointer) _elem32, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_double_set = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 25:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            guint32 i;
            for (i = 0; i < size; ++i)
            {
              gchar * _elem33 = NULL;
              if (_elem33 != NULL)
              {
                g_free(_elem33);
                _elem33 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem33, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *) this_object->string_set, (gpointer) _elem33, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_string_set = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 26:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            guint32 i;
            for (i = 0; i < size; ++i)
            {
              GByteArray * _elem34 = NULL;
              if (_elem34 != NULL)
              {
                g_free(_elem34);
                _elem34 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem34 = g_byte_array_new();
              g_byte_array_append (_elem34, (guint8 *) data, (guint) len);
              g_free (data);
              g_hash_table_insert ((GHashTable *) this_object->binary_set, (gpointer) _elem34, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_binary_set = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 27:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            guint32 i;
            for (i = 0; i < size; ++i)
            {
              gboolean* _elem35 = g_new (gboolean, 1);
              if ((ret = thrift_protocol_read_bool (protocol, &*_elem35, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *) this_object->boolean_set, (gpointer) _elem35, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_boolean_set = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 28:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            guint32 i;
            for (i = 0; i < size; ++i)
            {
              TTestEmpty * _elem36 = NULL;
              if ( _elem36 != NULL)
              {
                g_object_unref (_elem36);
              }
              _elem36 = g_object_new (T_TEST_TYPE_EMPTY, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem36), protocol, error)) < 0)
              {
                g_object_unref (_elem36);
                return -1;
              }
              xfer += ret;
              g_hash_table_insert ((GHashTable *) this_object->struct_set, (gpointer) _elem36, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_struct_set = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 29:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint8* key37 = g_new (gint8, 1);
              gint8* val38 = g_new (gint8, 1);
              if ((ret = thrift_protocol_read_byte (protocol, &*key37, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_byte (protocol, &*val38, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->byte_byte_map, (gpointer) key37, (gpointer) val38);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_byte_byte_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 30:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint16* key39 = g_new (gint16, 1);
              gint8* val40 = g_new (gint8, 1);
              if ((ret = thrift_protocol_read_i16 (protocol, &*key39, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_byte (protocol, &*val40, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->i16_byte_map, (gpointer) key39, (gpointer) val40);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_i16_byte_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 31:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint32* key41 = g_new (gint32, 1);
              gint8* val42 = g_new (gint8, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*key41, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_byte (protocol, &*val42, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->i32_byte_map, (gpointer) key41, (gpointer) val42);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_i32_byte_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 32:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint64* key43 = g_new (gint64, 1);
              gint8* val44 = g_new (gint8, 1);
              if ((ret = thrift_protocol_read_i64 (protocol, &*key43, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_byte (protocol, &*val44, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->i64_byte_map, (gpointer) key43, (gpointer) val44);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_i64_byte_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 33:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gdouble* key45 = g_new (gdouble, 1);
              gint8* val46 = g_new (gint8, 1);
              if ((ret = thrift_protocol_read_double (protocol, &*key45, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_byte (protocol, &*val46, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->double_byte_map, (gpointer) key45, (gpointer) val46);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_double_byte_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 34:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gchar * key47 = NULL;
              gint8* val48 = g_new (gint8, 1);
              if (key47 != NULL)
              {
                g_free(key47);
                key47 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key47, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_byte (protocol, &*val48, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->string_byte_map, (gpointer) key47, (gpointer) val48);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_string_byte_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 35:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              GByteArray * key49 = NULL;
              gint8* val50 = g_new (gint8, 1);
              if (key49 != NULL)
              {
                g_free(key49);
                key49 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key49 = g_byte_array_new();
              g_byte_array_append (key49, (guint8 *) data, (guint) len);
              g_free (data);
              if ((ret = thrift_protocol_read_byte (protocol, &*val50, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->binary_byte_map, (gpointer) key49, (gpointer) val50);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_binary_byte_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 36:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gboolean* key51 = g_new (gboolean, 1);
              gint8* val52 = g_new (gint8, 1);
              if ((ret = thrift_protocol_read_bool (protocol, &*key51, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_byte (protocol, &*val52, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->boolean_byte_map, (gpointer) key51, (gpointer) val52);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_boolean_byte_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 37:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint8* key53 = g_new (gint8, 1);
              gint16* val54 = g_new (gint16, 1);
              if ((ret = thrift_protocol_read_byte (protocol, &*key53, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_i16 (protocol, &*val54, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->byte_i16_map, (gpointer) key53, (gpointer) val54);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_byte_i16_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 38:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint8* key55 = g_new (gint8, 1);
              gint32* val56 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_byte (protocol, &*key55, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_i32 (protocol, &*val56, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->byte_i32_map, (gpointer) key55, (gpointer) val56);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_byte_i32_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 39:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint8* key57 = g_new (gint8, 1);
              gint64* val58 = g_new (gint64, 1);
              if ((ret = thrift_protocol_read_byte (protocol, &*key57, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_i64 (protocol, &*val58, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->byte_i64_map, (gpointer) key57, (gpointer) val58);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_byte_i64_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 40:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint8* key59 = g_new (gint8, 1);
              gdouble* val60 = g_new (gdouble, 1);
              if ((ret = thrift_protocol_read_byte (protocol, &*key59, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_double (protocol, &*val60, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->byte_double_map, (gpointer) key59, (gpointer) val60);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_byte_double_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 41:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint8* key61 = g_new (gint8, 1);
              gchar * val62 = NULL;
              if ((ret = thrift_protocol_read_byte (protocol, &*key61, error)) < 0)
                return -1;
              xfer += ret;
              if (val62 != NULL)
              {
                g_free(val62);
                val62 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val62, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->byte_string_map, (gpointer) key61, (gpointer) val62);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_byte_string_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 42:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint8* key63 = g_new (gint8, 1);
              GByteArray * val64 = NULL;
              if ((ret = thrift_protocol_read_byte (protocol, &*key63, error)) < 0)
                return -1;
              xfer += ret;
              if (val64 != NULL)
              {
                g_free(val64);
                val64 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val64 = g_byte_array_new();
              g_byte_array_append (val64, (guint8 *) data, (guint) len);
              g_free (data);
              g_hash_table_insert ((GHashTable *)this_object->byte_binary_map, (gpointer) key63, (gpointer) val64);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_byte_binary_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 43:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint8* key65 = g_new (gint8, 1);
              gboolean* val66 = g_new (gboolean, 1);
              if ((ret = thrift_protocol_read_byte (protocol, &*key65, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_bool (protocol, &*val66, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->byte_boolean_map, (gpointer) key65, (gpointer) val66);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_byte_boolean_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 44:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              GArray * key67 = NULL;
              gint8* val68 = g_new (gint8, 1);
              {
                guint32 size;
                ThriftType element_type;
                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                guint32 i;
                for (i = 0; i < size; i++)
                {
                  gint8* _elem69 = g_new (gint8, 1);
                  if ((ret = thrift_protocol_read_byte (protocol, &*_elem69, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_array_append_vals (key67, _elem69, 1);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;

              }
              if ((ret = thrift_protocol_read_byte (protocol, &*val68, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->list_byte_map, (gpointer) key67, (gpointer) val68);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_list_byte_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 45:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              GHashTable * key70 = NULL;
              gint8* val71 = g_new (gint8, 1);
              {
                guint32 size;
                ThriftType element_type;
                if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through the set elements */
                guint32 i;
                for (i = 0; i < size; ++i)
                {
                  gint8* _elem72 = g_new (gint8, 1);
                  if ((ret = thrift_protocol_read_byte (protocol, &*_elem72, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_hash_table_insert ((GHashTable *) key70, (gpointer) _elem72, (gpointer) 1);
                }
                if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;

              }
              if ((ret = thrift_protocol_read_byte (protocol, &*val71, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->set_byte_map, (gpointer) key70, (gpointer) val71);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_set_byte_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 46:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              GHashTable * key73 = g_hash_table_new (NULL, NULL);
              gint8* val74 = g_new (gint8, 1);
              {
                guint32 size;
                ThriftType key_type;
                ThriftType value_type;

                /* read the map begin marker */
                if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through each of the map's fields */
                guint32 i;
                for (i = 0; i < size; i++)
                {
                  gint8* key75 = g_new (gint8, 1);
                  gint8* val76 = g_new (gint8, 1);
                  if ((ret = thrift_protocol_read_byte (protocol, &*key75, error)) < 0)
                    return -1;
                  xfer += ret;
                  if ((ret = thrift_protocol_read_byte (protocol, &*val76, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_hash_table_insert ((GHashTable *)key73, (gpointer) key75, (gpointer) val76);
                }

                /* read the map end marker */
                if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              if ((ret = thrift_protocol_read_byte (protocol, &*val74, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->map_byte_map, (gpointer) key73, (gpointer) val74);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_map_byte_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 47:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint8* key77 = g_new (gint8, 1);
              GHashTable * val78 = g_hash_table_new (NULL, NULL);
              if ((ret = thrift_protocol_read_byte (protocol, &*key77, error)) < 0)
                return -1;
              xfer += ret;
              {
                guint32 size;
                ThriftType key_type;
                ThriftType value_type;

                /* read the map begin marker */
                if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through each of the map's fields */
                guint32 i;
                for (i = 0; i < size; i++)
                {
                  gint8* key79 = g_new (gint8, 1);
                  gint8* val80 = g_new (gint8, 1);
                  if ((ret = thrift_protocol_read_byte (protocol, &*key79, error)) < 0)
                    return -1;
                  xfer += ret;
                  if ((ret = thrift_protocol_read_byte (protocol, &*val80, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_hash_table_insert ((GHashTable *)val78, (gpointer) key79, (gpointer) val80);
                }

                /* read the map end marker */
                if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              g_hash_table_insert ((GHashTable *)this_object->byte_map_map, (gpointer) key77, (gpointer) val78);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_byte_map_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 48:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint8* key81 = g_new (gint8, 1);
              GHashTable * val82 = NULL;
              if ((ret = thrift_protocol_read_byte (protocol, &*key81, error)) < 0)
                return -1;
              xfer += ret;
              {
                guint32 size;
                ThriftType element_type;
                if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through the set elements */
                guint32 i;
                for (i = 0; i < size; ++i)
                {
                  gint8* _elem83 = g_new (gint8, 1);
                  if ((ret = thrift_protocol_read_byte (protocol, &*_elem83, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_hash_table_insert ((GHashTable *) val82, (gpointer) _elem83, (gpointer) 1);
                }
                if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;

              }
              g_hash_table_insert ((GHashTable *)this_object->byte_set_map, (gpointer) key81, (gpointer) val82);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_byte_set_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 49:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint8* key84 = g_new (gint8, 1);
              GArray * val85 = NULL;
              if ((ret = thrift_protocol_read_byte (protocol, &*key84, error)) < 0)
                return -1;
              xfer += ret;
              {
                guint32 size;
                ThriftType element_type;
                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                guint32 i;
                for (i = 0; i < size; i++)
                {
                  gint8* _elem86 = g_new (gint8, 1);
                  if ((ret = thrift_protocol_read_byte (protocol, &*_elem86, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_array_append_vals (val85, _elem86, 1);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;

              }
              g_hash_table_insert ((GHashTable *)this_object->byte_list_map, (gpointer) key84, (gpointer) val85);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_byte_list_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_compact_proto_test_struct_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestCompactProtoTestStruct * this_object = T_TEST_COMPACT_PROTO_TEST_STRUCT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CompactProtoTestStruct", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "a_byte", T_BYTE, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->a_byte, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "a_i16", T_I16, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->a_i16, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "a_i32", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->a_i32, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "a_i64", T_I64, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->a_i64, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "a_double", T_DOUBLE, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->a_double, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "a_string", T_STRING, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->a_string, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "a_binary", T_STRING, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->a_binary)->data, ((GByteArray *) this_object->a_binary)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "true_field", T_BOOL, 8, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->true_field, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "false_field", T_BOOL, 9, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->false_field, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "empty_struct_field", T_STRUCT, 10, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->empty_struct_field), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_list", T_LIST, 11, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_BYTE, (gint32) this_object->byte_list->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i87;
    for (i87=0; i87<this_object->byte_list->len; i87++)
    {
      if ((ret = thrift_protocol_write_byte (protocol, (g_array_index (this_object->byte_list, gint8, i87)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i16_list", T_LIST, 12, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_I16, (gint32) this_object->i16_list->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i88;
    for (i88=0; i88<this_object->i16_list->len; i88++)
    {
      if ((ret = thrift_protocol_write_i16 (protocol, (g_array_index (this_object->i16_list, gint16, i88)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i32_list", T_LIST, 13, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) this_object->i32_list->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i89;
    for (i89=0; i89<this_object->i32_list->len; i89++)
    {
      if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->i32_list, gint32, i89)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i64_list", T_LIST, 14, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_I64, (gint32) this_object->i64_list->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i90;
    for (i90=0; i90<this_object->i64_list->len; i90++)
    {
      if ((ret = thrift_protocol_write_i64 (protocol, (g_array_index (this_object->i64_list, gint64, i90)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "double_list", T_LIST, 15, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_DOUBLE, (gint32) this_object->double_list->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i91;
    for (i91=0; i91<this_object->double_list->len; i91++)
    {
      if ((ret = thrift_protocol_write_double (protocol, (g_array_index (this_object->double_list, gdouble, i91)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "string_list", T_LIST, 16, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) this_object->string_list->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i92;
    for (i92=0; i92<this_object->string_list->len; i92++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->string_list, i92)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "binary_list", T_LIST, 17, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) this_object->binary_list->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i93;
    for (i93=0; i93<this_object->binary_list->len; i93++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->binary_list, i93)))->data, ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->binary_list, i93)))->len, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "boolean_list", T_LIST, 18, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_BOOL, (gint32) this_object->boolean_list->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i94;
    for (i94=0; i94<this_object->boolean_list->len; i94++)
    {
      if ((ret = thrift_protocol_write_bool (protocol, (g_array_index (this_object->boolean_list, gboolean, i94)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "struct_list", T_LIST, 19, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->struct_list->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i95;
    for (i95=0; i95<this_object->struct_list->len; i95++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->struct_list, i95))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_set", T_SET, 20, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_set_begin (protocol, T_BYTE, (gint32) g_hash_table_size ((GHashTable *) this_object->byte_set), error)) < 0)
      return -1;
    xfer += ret;
    GList *key_list = NULL, *iter = NULL;
    gint8* elem;
    gpointer value;
    THRIFT_UNUSED_VAR (value);

    g_hash_table_foreach ((GHashTable *) this_object->byte_set, thrift_hash_table_get_keys, &key_list);
    gint8* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gint8*) iter->data;
    }
    g_list_free (key_list);

    for (i=0; i<key_count; ++i)
    {
      elem = keys[i];
      value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->byte_set), (gpointer) elem);

      if ((ret = thrift_protocol_write_byte (protocol, *elem, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i16_set", T_SET, 21, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_set_begin (protocol, T_I16, (gint32) g_hash_table_size ((GHashTable *) this_object->i16_set), error)) < 0)
      return -1;
    xfer += ret;
    GList *key_list = NULL, *iter = NULL;
    gint16* elem;
    gpointer value;
    THRIFT_UNUSED_VAR (value);

    g_hash_table_foreach ((GHashTable *) this_object->i16_set, thrift_hash_table_get_keys, &key_list);
    gint16* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gint16*) iter->data;
    }
    g_list_free (key_list);

    for (i=0; i<key_count; ++i)
    {
      elem = keys[i];
      value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->i16_set), (gpointer) elem);

      if ((ret = thrift_protocol_write_i16 (protocol, *elem, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i32_set", T_SET, 22, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_set_begin (protocol, T_I32, (gint32) g_hash_table_size ((GHashTable *) this_object->i32_set), error)) < 0)
      return -1;
    xfer += ret;
    GList *key_list = NULL, *iter = NULL;
    gint32* elem;
    gpointer value;
    THRIFT_UNUSED_VAR (value);

    g_hash_table_foreach ((GHashTable *) this_object->i32_set, thrift_hash_table_get_keys, &key_list);
    gint32* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gint32*) iter->data;
    }
    g_list_free (key_list);

    for (i=0; i<key_count; ++i)
    {
      elem = keys[i];
      value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->i32_set), (gpointer) elem);

      if ((ret = thrift_protocol_write_i32 (protocol, *elem, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i64_set", T_SET, 23, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_set_begin (protocol, T_I64, (gint32) g_hash_table_size ((GHashTable *) this_object->i64_set), error)) < 0)
      return -1;
    xfer += ret;
    GList *key_list = NULL, *iter = NULL;
    gint64* elem;
    gpointer value;
    THRIFT_UNUSED_VAR (value);

    g_hash_table_foreach ((GHashTable *) this_object->i64_set, thrift_hash_table_get_keys, &key_list);
    gint64* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gint64*) iter->data;
    }
    g_list_free (key_list);

    for (i=0; i<key_count; ++i)
    {
      elem = keys[i];
      value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->i64_set), (gpointer) elem);

      if ((ret = thrift_protocol_write_i64 (protocol, *elem, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "double_set", T_SET, 24, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_set_begin (protocol, T_DOUBLE, (gint32) g_hash_table_size ((GHashTable *) this_object->double_set), error)) < 0)
      return -1;
    xfer += ret;
    GList *key_list = NULL, *iter = NULL;
    gdouble* elem;
    gpointer value;
    THRIFT_UNUSED_VAR (value);

    g_hash_table_foreach ((GHashTable *) this_object->double_set, thrift_hash_table_get_keys, &key_list);
    gdouble* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gdouble*) iter->data;
    }
    g_list_free (key_list);

    for (i=0; i<key_count; ++i)
    {
      elem = keys[i];
      value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->double_set), (gpointer) elem);

      if ((ret = thrift_protocol_write_double (protocol, *elem, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "string_set", T_SET, 25, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_set_begin (protocol, T_STRING, (gint32) g_hash_table_size ((GHashTable *) this_object->string_set), error)) < 0)
      return -1;
    xfer += ret;
    GList *key_list = NULL, *iter = NULL;
    gchar * elem;
    gpointer value;
    THRIFT_UNUSED_VAR (value);

    g_hash_table_foreach ((GHashTable *) this_object->string_set, thrift_hash_table_get_keys, &key_list);
    gchar * keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gchar *) iter->data;
    }
    g_list_free (key_list);

    for (i=0; i<key_count; ++i)
    {
      elem = keys[i];
      value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->string_set), (gpointer) elem);

      if ((ret = thrift_protocol_write_string (protocol, elem, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "binary_set", T_SET, 26, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_set_begin (protocol, T_STRING, (gint32) g_hash_table_size ((GHashTable *) this_object->binary_set), error)) < 0)
      return -1;
    xfer += ret;
    GList *key_list = NULL, *iter = NULL;
    GByteArray * elem;
    gpointer value;
    THRIFT_UNUSED_VAR (value);

    g_hash_table_foreach ((GHashTable *) this_object->binary_set, thrift_hash_table_get_keys, &key_list);
    GByteArray * keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (GByteArray *) iter->data;
    }
    g_list_free (key_list);

    for (i=0; i<key_count; ++i)
    {
      elem = keys[i];
      value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->binary_set), (gpointer) elem);

      if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) elem)->data, ((GByteArray *) elem)->len, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "boolean_set", T_SET, 27, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_set_begin (protocol, T_BOOL, (gint32) g_hash_table_size ((GHashTable *) this_object->boolean_set), error)) < 0)
      return -1;
    xfer += ret;
    GList *key_list = NULL, *iter = NULL;
    gboolean* elem;
    gpointer value;
    THRIFT_UNUSED_VAR (value);

    g_hash_table_foreach ((GHashTable *) this_object->boolean_set, thrift_hash_table_get_keys, &key_list);
    gboolean* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gboolean*) iter->data;
    }
    g_list_free (key_list);

    for (i=0; i<key_count; ++i)
    {
      elem = keys[i];
      value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->boolean_set), (gpointer) elem);

      if ((ret = thrift_protocol_write_bool (protocol, *elem, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "struct_set", T_SET, 28, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_set_begin (protocol, T_STRUCT, (gint32) g_hash_table_size ((GHashTable *) this_object->struct_set), error)) < 0)
      return -1;
    xfer += ret;
    GList *key_list = NULL, *iter = NULL;
    TTestEmpty * elem;
    gpointer value;
    THRIFT_UNUSED_VAR (value);

    g_hash_table_foreach ((GHashTable *) this_object->struct_set, thrift_hash_table_get_keys, &key_list);
    TTestEmpty * keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (TTestEmpty *) iter->data;
    }
    g_list_free (key_list);

    for (i=0; i<key_count; ++i)
    {
      elem = keys[i];
      value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->struct_set), (gpointer) elem);

      if ((ret = thrift_struct_write (THRIFT_STRUCT (elem), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_byte_map", T_MAP, 29, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_BYTE, T_BYTE, (gint32) g_hash_table_size ((GHashTable *) this_object->byte_byte_map), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gint8* key;
    gint8* value;
    g_hash_table_foreach ((GHashTable *) this_object->byte_byte_map, thrift_hash_table_get_keys, &key_list);
    gint8* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gint8*) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (gint8*) g_hash_table_lookup (((GHashTable *) this_object->byte_byte_map), (gpointer) key);

      if ((ret = thrift_protocol_write_byte (protocol, * key, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_byte (protocol, * value, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i16_byte_map", T_MAP, 30, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_I16, T_BYTE, (gint32) g_hash_table_size ((GHashTable *) this_object->i16_byte_map), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gint16* key;
    gint8* value;
    g_hash_table_foreach ((GHashTable *) this_object->i16_byte_map, thrift_hash_table_get_keys, &key_list);
    gint16* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gint16*) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (gint8*) g_hash_table_lookup (((GHashTable *) this_object->i16_byte_map), (gpointer) key);

      if ((ret = thrift_protocol_write_i16 (protocol, * key, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_byte (protocol, * value, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i32_byte_map", T_MAP, 31, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_BYTE, (gint32) g_hash_table_size ((GHashTable *) this_object->i32_byte_map), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gint32* key;
    gint8* value;
    g_hash_table_foreach ((GHashTable *) this_object->i32_byte_map, thrift_hash_table_get_keys, &key_list);
    gint32* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gint32*) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (gint8*) g_hash_table_lookup (((GHashTable *) this_object->i32_byte_map), (gpointer) key);

      if ((ret = thrift_protocol_write_i32 (protocol, * key, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_byte (protocol, * value, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i64_byte_map", T_MAP, 32, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_I64, T_BYTE, (gint32) g_hash_table_size ((GHashTable *) this_object->i64_byte_map), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gint64* key;
    gint8* value;
    g_hash_table_foreach ((GHashTable *) this_object->i64_byte_map, thrift_hash_table_get_keys, &key_list);
    gint64* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gint64*) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (gint8*) g_hash_table_lookup (((GHashTable *) this_object->i64_byte_map), (gpointer) key);

      if ((ret = thrift_protocol_write_i64 (protocol, * key, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_byte (protocol, * value, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "double_byte_map", T_MAP, 33, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_DOUBLE, T_BYTE, (gint32) g_hash_table_size ((GHashTable *) this_object->double_byte_map), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gdouble* key;
    gint8* value;
    g_hash_table_foreach ((GHashTable *) this_object->double_byte_map, thrift_hash_table_get_keys, &key_list);
    gdouble* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gdouble*) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (gint8*) g_hash_table_lookup (((GHashTable *) this_object->double_byte_map), (gpointer) key);

      if ((ret = thrift_protocol_write_double (protocol, * key, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_byte (protocol, * value, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "string_byte_map", T_MAP, 34, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_BYTE, (gint32) g_hash_table_size ((GHashTable *) this_object->string_byte_map), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gchar * key;
    gint8* value;
    g_hash_table_foreach ((GHashTable *) this_object->string_byte_map, thrift_hash_table_get_keys, &key_list);
    gchar * keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gchar *) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (gint8*) g_hash_table_lookup (((GHashTable *) this_object->string_byte_map), (gpointer) key);

      if ((ret = thrift_protocol_write_string (protocol,  key, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_byte (protocol, * value, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "binary_byte_map", T_MAP, 35, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_BYTE, (gint32) g_hash_table_size ((GHashTable *) this_object->binary_byte_map), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    GByteArray * key;
    gint8* value;
    g_hash_table_foreach ((GHashTable *) this_object->binary_byte_map, thrift_hash_table_get_keys, &key_list);
    GByteArray * keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (GByteArray *) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (gint8*) g_hash_table_lookup (((GHashTable *) this_object->binary_byte_map), (gpointer) key);

      if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *)  key)->data, ((GByteArray *)  key)->len, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_byte (protocol, * value, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "boolean_byte_map", T_MAP, 36, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_BOOL, T_BYTE, (gint32) g_hash_table_size ((GHashTable *) this_object->boolean_byte_map), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gboolean* key;
    gint8* value;
    g_hash_table_foreach ((GHashTable *) this_object->boolean_byte_map, thrift_hash_table_get_keys, &key_list);
    gboolean* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gboolean*) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (gint8*) g_hash_table_lookup (((GHashTable *) this_object->boolean_byte_map), (gpointer) key);

      if ((ret = thrift_protocol_write_bool (protocol, * key, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_byte (protocol, * value, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_i16_map", T_MAP, 37, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_BYTE, T_I16, (gint32) g_hash_table_size ((GHashTable *) this_object->byte_i16_map), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gint8* key;
    gint16* value;
    g_hash_table_foreach ((GHashTable *) this_object->byte_i16_map, thrift_hash_table_get_keys, &key_list);
    gint8* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gint8*) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (gint16*) g_hash_table_lookup (((GHashTable *) this_object->byte_i16_map), (gpointer) key);

      if ((ret = thrift_protocol_write_byte (protocol, * key, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_i16 (protocol, * value, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_i32_map", T_MAP, 38, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_BYTE, T_I32, (gint32) g_hash_table_size ((GHashTable *) this_object->byte_i32_map), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gint8* key;
    gint32* value;
    g_hash_table_foreach ((GHashTable *) this_object->byte_i32_map, thrift_hash_table_get_keys, &key_list);
    gint8* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gint8*) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (gint32*) g_hash_table_lookup (((GHashTable *) this_object->byte_i32_map), (gpointer) key);

      if ((ret = thrift_protocol_write_byte (protocol, * key, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_i32 (protocol, * value, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_i64_map", T_MAP, 39, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_BYTE, T_I64, (gint32) g_hash_table_size ((GHashTable *) this_object->byte_i64_map), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gint8* key;
    gint64* value;
    g_hash_table_foreach ((GHashTable *) this_object->byte_i64_map, thrift_hash_table_get_keys, &key_list);
    gint8* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gint8*) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (gint64*) g_hash_table_lookup (((GHashTable *) this_object->byte_i64_map), (gpointer) key);

      if ((ret = thrift_protocol_write_byte (protocol, * key, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_i64 (protocol, * value, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_double_map", T_MAP, 40, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_BYTE, T_DOUBLE, (gint32) g_hash_table_size ((GHashTable *) this_object->byte_double_map), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gint8* key;
    gdouble* value;
    g_hash_table_foreach ((GHashTable *) this_object->byte_double_map, thrift_hash_table_get_keys, &key_list);
    gint8* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gint8*) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (gdouble*) g_hash_table_lookup (((GHashTable *) this_object->byte_double_map), (gpointer) key);

      if ((ret = thrift_protocol_write_byte (protocol, * key, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_double (protocol, * value, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_string_map", T_MAP, 41, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_BYTE, T_STRING, (gint32) g_hash_table_size ((GHashTable *) this_object->byte_string_map), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gint8* key;
    gchar * value;
    g_hash_table_foreach ((GHashTable *) this_object->byte_string_map, thrift_hash_table_get_keys, &key_list);
    gint8* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gint8*) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->byte_string_map), (gpointer) key);

      if ((ret = thrift_protocol_write_byte (protocol, * key, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_string (protocol,  value, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_binary_map", T_MAP, 42, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_BYTE, T_STRING, (gint32) g_hash_table_size ((GHashTable *) this_object->byte_binary_map), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gint8* key;
    GByteArray * value;
    g_hash_table_foreach ((GHashTable *) this_object->byte_binary_map, thrift_hash_table_get_keys, &key_list);
    gint8* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gint8*) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (GByteArray *) g_hash_table_lookup (((GHashTable *) this_object->byte_binary_map), (gpointer) key);

      if ((ret = thrift_protocol_write_byte (protocol, * key, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *)  value)->data, ((GByteArray *)  value)->len, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_boolean_map", T_MAP, 43, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_BYTE, T_BOOL, (gint32) g_hash_table_size ((GHashTable *) this_object->byte_boolean_map), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gint8* key;
    gboolean* value;
    g_hash_table_foreach ((GHashTable *) this_object->byte_boolean_map, thrift_hash_table_get_keys, &key_list);
    gint8* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gint8*) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (gboolean*) g_hash_table_lookup (((GHashTable *) this_object->byte_boolean_map), (gpointer) key);

      if ((ret = thrift_protocol_write_byte (protocol, * key, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_bool (protocol, * value, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "list_byte_map", T_MAP, 44, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_LIST, T_BYTE, (gint32) g_hash_table_size ((GHashTable *) this_object->list_byte_map), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    GArray * key;
    gint8* value;
    g_hash_table_foreach ((GHashTable *) this_object->list_byte_map, thrift_hash_table_get_keys, &key_list);
    GArray * keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (GArray *) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (gint8*) g_hash_table_lookup (((GHashTable *) this_object->list_byte_map), (gpointer) key);

      {
        if ((ret = thrift_protocol_write_list_begin (protocol, T_BYTE, (gint32)  key->len, error)) < 0)
          return -1;
        xfer += ret;
        guint i96;
        for (i96=0; i96< key->len; i96++)
        {
          if ((ret = thrift_protocol_write_byte (protocol, (g_array_index ( key, gint8, i96)), error)) < 0)
            return -1;
        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
      if ((ret = thrift_protocol_write_byte (protocol, * value, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "set_byte_map", T_MAP, 45, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_SET, T_BYTE, (gint32) g_hash_table_size ((GHashTable *) this_object->set_byte_map), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    GHashTable * key;
    gint8* value;
    g_hash_table_foreach ((GHashTable *) this_object->set_byte_map, thrift_hash_table_get_keys, &key_list);
    GHashTable * keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (GHashTable *) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (gint8*) g_hash_table_lookup (((GHashTable *) this_object->set_byte_map), (gpointer) key);

      {
        if ((ret = thrift_protocol_write_set_begin (protocol, T_BYTE, (gint32) g_hash_table_size ((GHashTable *)  key), error)) < 0)
          return -1;
        xfer += ret;
        GList *key_list = NULL, *iter = NULL;
        gint8* elem;
        gpointer value;
        THRIFT_UNUSED_VAR (value);

        g_hash_table_foreach ((GHashTable *)  key, thrift_hash_table_get_keys, &key_list);
        gint8* keys[g_list_length (key_list)];
        int i=0, key_count = g_list_length (key_list);
        for (iter = g_list_first (key_list); iter; iter = iter->next)
        {
          keys[i++] = (gint8*) iter->data;
        }
        g_list_free (key_list);

        for (i=0; i<key_count; ++i)
        {
          elem = keys[i];
          value = (gpointer) g_hash_table_lookup (((GHashTable *)  key), (gpointer) elem);

          if ((ret = thrift_protocol_write_byte (protocol, *elem, error)) < 0)
            return -1;
        }
        if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
      if ((ret = thrift_protocol_write_byte (protocol, * value, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "map_byte_map", T_MAP, 46, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_MAP, T_BYTE, (gint32) g_hash_table_size ((GHashTable *) this_object->map_byte_map), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    GHashTable * key;
    gint8* value;
    g_hash_table_foreach ((GHashTable *) this_object->map_byte_map, thrift_hash_table_get_keys, &key_list);
    GHashTable * keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (GHashTable *) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (gint8*) g_hash_table_lookup (((GHashTable *) this_object->map_byte_map), (gpointer) key);

      {
        if ((ret = thrift_protocol_write_map_begin (protocol, T_BYTE, T_BYTE, (gint32) g_hash_table_size ((GHashTable *)  key), error)) < 0)
          return -1;
        xfer += ret;

        GList *key_list = NULL, *iter = NULL;
        gint8* key;
        gint8* value;
        g_hash_table_foreach ((GHashTable *)  key, thrift_hash_table_get_keys, &key_list);
        gint8* keys[g_list_length (key_list)];
        int i=0, key_count = g_list_length (key_list);
        for (iter = g_list_first (key_list); iter; iter = iter->next)
        {
          keys[i++] = (gint8*) iter->data;
        }
        g_list_free (key_list);

        for (i = 0; i < key_count; ++i)
        {
          key = keys[i];
          value = (gint8*) g_hash_table_lookup (((GHashTable *)  key), (gpointer) key);

          if ((ret = thrift_protocol_write_byte (protocol, * key, error)) < 0)
            return -1;
          if ((ret = thrift_protocol_write_byte (protocol, * value, error)) < 0)
            return -1;
        }
        if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
      if ((ret = thrift_protocol_write_byte (protocol, * value, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_map_map", T_MAP, 47, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_BYTE, T_MAP, (gint32) g_hash_table_size ((GHashTable *) this_object->byte_map_map), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gint8* key;
    GHashTable * value;
    g_hash_table_foreach ((GHashTable *) this_object->byte_map_map, thrift_hash_table_get_keys, &key_list);
    gint8* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gint8*) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (GHashTable *) g_hash_table_lookup (((GHashTable *) this_object->byte_map_map), (gpointer) key);

      if ((ret = thrift_protocol_write_byte (protocol, * key, error)) < 0)
        return -1;
      {
        if ((ret = thrift_protocol_write_map_begin (protocol, T_BYTE, T_BYTE, (gint32) g_hash_table_size ((GHashTable *)  value), error)) < 0)
          return -1;
        xfer += ret;

        GList *key_list = NULL, *iter = NULL;
        gint8* key;
        gint8* value;
        g_hash_table_foreach ((GHashTable *)  value, thrift_hash_table_get_keys, &key_list);
        gint8* keys[g_list_length (key_list)];
        int i=0, key_count = g_list_length (key_list);
        for (iter = g_list_first (key_list); iter; iter = iter->next)
        {
          keys[i++] = (gint8*) iter->data;
        }
        g_list_free (key_list);

        for (i = 0; i < key_count; ++i)
        {
          key = keys[i];
          value = (gint8*) g_hash_table_lookup (((GHashTable *)  value), (gpointer) key);

          if ((ret = thrift_protocol_write_byte (protocol, * key, error)) < 0)
            return -1;
          if ((ret = thrift_protocol_write_byte (protocol, * value, error)) < 0)
            return -1;
        }
        if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_set_map", T_MAP, 48, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_BYTE, T_SET, (gint32) g_hash_table_size ((GHashTable *) this_object->byte_set_map), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gint8* key;
    GHashTable * value;
    g_hash_table_foreach ((GHashTable *) this_object->byte_set_map, thrift_hash_table_get_keys, &key_list);
    gint8* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gint8*) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (GHashTable *) g_hash_table_lookup (((GHashTable *) this_object->byte_set_map), (gpointer) key);

      if ((ret = thrift_protocol_write_byte (protocol, * key, error)) < 0)
        return -1;
      {
        if ((ret = thrift_protocol_write_set_begin (protocol, T_BYTE, (gint32) g_hash_table_size ((GHashTable *)  value), error)) < 0)
          return -1;
        xfer += ret;
        GList *key_list = NULL, *iter = NULL;
        gint8* elem;
        gpointer value;
        THRIFT_UNUSED_VAR (value);

        g_hash_table_foreach ((GHashTable *)  value, thrift_hash_table_get_keys, &key_list);
        gint8* keys[g_list_length (key_list)];
        int i=0, key_count = g_list_length (key_list);
        for (iter = g_list_first (key_list); iter; iter = iter->next)
        {
          keys[i++] = (gint8*) iter->data;
        }
        g_list_free (key_list);

        for (i=0; i<key_count; ++i)
        {
          elem = keys[i];
          value = (gpointer) g_hash_table_lookup (((GHashTable *)  value), (gpointer) elem);

          if ((ret = thrift_protocol_write_byte (protocol, *elem, error)) < 0)
            return -1;
        }
        if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_list_map", T_MAP, 49, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_BYTE, T_LIST, (gint32) g_hash_table_size ((GHashTable *) this_object->byte_list_map), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gint8* key;
    GArray * value;
    g_hash_table_foreach ((GHashTable *) this_object->byte_list_map, thrift_hash_table_get_keys, &key_list);
    gint8* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gint8*) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (GArray *) g_hash_table_lookup (((GHashTable *) this_object->byte_list_map), (gpointer) key);

      if ((ret = thrift_protocol_write_byte (protocol, * key, error)) < 0)
        return -1;
      {
        if ((ret = thrift_protocol_write_list_begin (protocol, T_BYTE, (gint32)  value->len, error)) < 0)
          return -1;
        xfer += ret;
        guint i97;
        for (i97=0; i97< value->len; i97++)
        {
          if ((ret = thrift_protocol_write_byte (protocol, (g_array_index ( value, gint8, i97)), error)) < 0)
            return -1;
        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_compact_proto_test_struct_instance_init (TTestCompactProtoTestStruct * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->a_byte = 0;
  object->__isset_a_byte = FALSE;
  object->a_i16 = 0;
  object->__isset_a_i16 = FALSE;
  object->a_i32 = 0;
  object->__isset_a_i32 = FALSE;
  object->a_i64 = 0;
  object->__isset_a_i64 = FALSE;
  object->a_double = 0;
  object->__isset_a_double = FALSE;
  object->a_string = NULL;
  object->__isset_a_string = FALSE;
  object->a_binary = NULL;
  object->__isset_a_binary = FALSE;
  object->true_field = 0;
  object->__isset_true_field = FALSE;
  object->false_field = 0;
  object->__isset_false_field = FALSE;
  object->empty_struct_field = g_object_new (T_TEST_TYPE_EMPTY, NULL);
  object->__isset_empty_struct_field = FALSE;
  object->byte_list = g_array_new (0, 1, sizeof (gint8));
  object->__isset_byte_list = FALSE;
  object->i16_list = g_array_new (0, 1, sizeof (gint16));
  object->__isset_i16_list = FALSE;
  object->i32_list = g_array_new (0, 1, sizeof (gint32));
  object->__isset_i32_list = FALSE;
  object->i64_list = g_array_new (0, 1, sizeof (gint64));
  object->__isset_i64_list = FALSE;
  object->double_list = g_array_new (0, 1, sizeof (gdouble));
  object->__isset_double_list = FALSE;
  object->string_list = g_ptr_array_new_with_free_func (g_free);
  object->__isset_string_list = FALSE;
  object->binary_list = g_ptr_array_new_with_free_func (g_free);
  object->__isset_binary_list = FALSE;
  object->boolean_list = g_array_new (0, 1, sizeof (gboolean));
  object->__isset_boolean_list = FALSE;
  object->struct_list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_struct_list = FALSE;
  object->byte_set = g_hash_table_new_full (g_int_hash, g_int_equal, NULL, NULL);
  object->__isset_byte_set = FALSE;
  object->i16_set = g_hash_table_new_full (g_int_hash, g_int_equal, NULL, NULL);
  object->__isset_i16_set = FALSE;
  object->i32_set = g_hash_table_new_full (g_int_hash, g_int_equal, NULL, NULL);
  object->__isset_i32_set = FALSE;
  object->i64_set = g_hash_table_new_full (g_int64_hash, g_int64_equal, NULL, NULL);
  object->__isset_i64_set = FALSE;
  object->double_set = g_hash_table_new_full (g_double_hash, g_double_equal, NULL, NULL);
  object->__isset_double_set = FALSE;
  object->string_set = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
  object->__isset_string_set = FALSE;
  object->binary_set = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
  object->__isset_binary_set = FALSE;
  object->boolean_set = g_hash_table_new_full (g_int_hash, g_int_equal, NULL, NULL);
  object->__isset_boolean_set = FALSE;
  object->struct_set = g_hash_table_new_full (g_direct_hash, g_direct_equal, g_object_unref, NULL);
  object->__isset_struct_set = FALSE;
  object->byte_byte_map = g_hash_table_new_full (g_int_hash, g_int_equal, NULL, NULL);
  object->__isset_byte_byte_map = FALSE;
  object->i16_byte_map = g_hash_table_new_full (g_int_hash, g_int_equal, NULL, NULL);
  object->__isset_i16_byte_map = FALSE;
  object->i32_byte_map = g_hash_table_new_full (g_int_hash, g_int_equal, NULL, NULL);
  object->__isset_i32_byte_map = FALSE;
  object->i64_byte_map = g_hash_table_new_full (g_int64_hash, g_int64_equal, NULL, NULL);
  object->__isset_i64_byte_map = FALSE;
  object->double_byte_map = g_hash_table_new_full (g_double_hash, g_double_equal, NULL, NULL);
  object->__isset_double_byte_map = FALSE;
  object->string_byte_map = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
  object->__isset_string_byte_map = FALSE;
  object->binary_byte_map = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
  object->__isset_binary_byte_map = FALSE;
  object->boolean_byte_map = g_hash_table_new_full (g_int_hash, g_int_equal, NULL, NULL);
  object->__isset_boolean_byte_map = FALSE;
  object->byte_i16_map = g_hash_table_new_full (g_int_hash, g_int_equal, NULL, NULL);
  object->__isset_byte_i16_map = FALSE;
  object->byte_i32_map = g_hash_table_new_full (g_int_hash, g_int_equal, NULL, NULL);
  object->__isset_byte_i32_map = FALSE;
  object->byte_i64_map = g_hash_table_new_full (g_int_hash, g_int_equal, NULL, NULL);
  object->__isset_byte_i64_map = FALSE;
  object->byte_double_map = g_hash_table_new_full (g_int_hash, g_int_equal, NULL, NULL);
  object->__isset_byte_double_map = FALSE;
  object->byte_string_map = g_hash_table_new_full (g_int_hash, g_int_equal, NULL, g_free);
  object->__isset_byte_string_map = FALSE;
  object->byte_binary_map = g_hash_table_new_full (g_int_hash, g_int_equal, NULL, g_free);
  object->__isset_byte_binary_map = FALSE;
  object->byte_boolean_map = g_hash_table_new_full (g_int_hash, g_int_equal, NULL, NULL);
  object->__isset_byte_boolean_map = FALSE;
  object->list_byte_map = g_hash_table_new_full (g_direct_hash, g_direct_equal, (GDestroyNotify) g_array_unref, NULL);
  object->__isset_list_byte_map = FALSE;
  object->set_byte_map = g_hash_table_new_full (g_direct_hash, g_direct_equal, (GDestroyNotify) g_hash_table_destroy, NULL);
  object->__isset_set_byte_map = FALSE;
  object->map_byte_map = g_hash_table_new_full (g_direct_hash, g_direct_equal, (GDestroyNotify) g_hash_table_destroy, NULL);
  object->__isset_map_byte_map = FALSE;
  object->byte_map_map = g_hash_table_new_full (g_int_hash, g_int_equal, NULL, (GDestroyNotify) g_hash_table_destroy);
  object->__isset_byte_map_map = FALSE;
  object->byte_set_map = g_hash_table_new_full (g_int_hash, g_int_equal, NULL, (GDestroyNotify) g_hash_table_destroy);
  object->__isset_byte_set_map = FALSE;
  object->byte_list_map = g_hash_table_new_full (g_int_hash, g_int_equal, NULL, (GDestroyNotify) g_array_unref);
  object->__isset_byte_list_map = FALSE;
}

static void 
t_test_compact_proto_test_struct_finalize (GObject *object)
{
  TTestCompactProtoTestStruct *tobject = T_TEST_COMPACT_PROTO_TEST_STRUCT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->a_string != NULL)
  {
    g_free (tobject->a_string);
    tobject->a_string = NULL;
  }
  if (tobject->a_binary != NULL)
  {
    g_free (tobject->a_binary);
    tobject->a_binary = NULL;
  }
  if (tobject->empty_struct_field != NULL)
  {
    g_object_unref(tobject->empty_struct_field);
    tobject->empty_struct_field = NULL;
  }
  if (tobject->byte_list != NULL)
  {
    g_array_free (tobject->byte_list, TRUE);
    tobject->byte_list = NULL;
  }
  if (tobject->i16_list != NULL)
  {
    g_array_free (tobject->i16_list, TRUE);
    tobject->i16_list = NULL;
  }
  if (tobject->i32_list != NULL)
  {
    g_array_free (tobject->i32_list, TRUE);
    tobject->i32_list = NULL;
  }
  if (tobject->i64_list != NULL)
  {
    g_array_free (tobject->i64_list, TRUE);
    tobject->i64_list = NULL;
  }
  if (tobject->double_list != NULL)
  {
    g_array_free (tobject->double_list, TRUE);
    tobject->double_list = NULL;
  }
  if (tobject->string_list != NULL)
  {
    g_ptr_array_free (tobject->string_list, TRUE);
    tobject->string_list = NULL;
  }
  if (tobject->binary_list != NULL)
  {
    g_ptr_array_free (tobject->binary_list, TRUE);
    tobject->binary_list = NULL;
  }
  if (tobject->boolean_list != NULL)
  {
    g_array_free (tobject->boolean_list, TRUE);
    tobject->boolean_list = NULL;
  }
  if (tobject->struct_list != NULL)
  {
    g_ptr_array_free (tobject->struct_list, TRUE);
    tobject->struct_list = NULL;
  }
  if (tobject->byte_set != NULL)
  {
    g_hash_table_destroy (tobject->byte_set);
    tobject->byte_set = NULL;
  }
  if (tobject->i16_set != NULL)
  {
    g_hash_table_destroy (tobject->i16_set);
    tobject->i16_set = NULL;
  }
  if (tobject->i32_set != NULL)
  {
    g_hash_table_destroy (tobject->i32_set);
    tobject->i32_set = NULL;
  }
  if (tobject->i64_set != NULL)
  {
    g_hash_table_destroy (tobject->i64_set);
    tobject->i64_set = NULL;
  }
  if (tobject->double_set != NULL)
  {
    g_hash_table_destroy (tobject->double_set);
    tobject->double_set = NULL;
  }
  if (tobject->string_set != NULL)
  {
    g_hash_table_destroy (tobject->string_set);
    tobject->string_set = NULL;
  }
  if (tobject->binary_set != NULL)
  {
    g_hash_table_destroy (tobject->binary_set);
    tobject->binary_set = NULL;
  }
  if (tobject->boolean_set != NULL)
  {
    g_hash_table_destroy (tobject->boolean_set);
    tobject->boolean_set = NULL;
  }
  if (tobject->struct_set != NULL)
  {
    g_hash_table_destroy (tobject->struct_set);
    tobject->struct_set = NULL;
  }
  if (tobject->byte_byte_map != NULL)
  {
    g_hash_table_destroy (tobject->byte_byte_map);
    tobject->byte_byte_map = NULL;
  }
  if (tobject->i16_byte_map != NULL)
  {
    g_hash_table_destroy (tobject->i16_byte_map);
    tobject->i16_byte_map = NULL;
  }
  if (tobject->i32_byte_map != NULL)
  {
    g_hash_table_destroy (tobject->i32_byte_map);
    tobject->i32_byte_map = NULL;
  }
  if (tobject->i64_byte_map != NULL)
  {
    g_hash_table_destroy (tobject->i64_byte_map);
    tobject->i64_byte_map = NULL;
  }
  if (tobject->double_byte_map != NULL)
  {
    g_hash_table_destroy (tobject->double_byte_map);
    tobject->double_byte_map = NULL;
  }
  if (tobject->string_byte_map != NULL)
  {
    g_hash_table_destroy (tobject->string_byte_map);
    tobject->string_byte_map = NULL;
  }
  if (tobject->binary_byte_map != NULL)
  {
    g_hash_table_destroy (tobject->binary_byte_map);
    tobject->binary_byte_map = NULL;
  }
  if (tobject->boolean_byte_map != NULL)
  {
    g_hash_table_destroy (tobject->boolean_byte_map);
    tobject->boolean_byte_map = NULL;
  }
  if (tobject->byte_i16_map != NULL)
  {
    g_hash_table_destroy (tobject->byte_i16_map);
    tobject->byte_i16_map = NULL;
  }
  if (tobject->byte_i32_map != NULL)
  {
    g_hash_table_destroy (tobject->byte_i32_map);
    tobject->byte_i32_map = NULL;
  }
  if (tobject->byte_i64_map != NULL)
  {
    g_hash_table_destroy (tobject->byte_i64_map);
    tobject->byte_i64_map = NULL;
  }
  if (tobject->byte_double_map != NULL)
  {
    g_hash_table_destroy (tobject->byte_double_map);
    tobject->byte_double_map = NULL;
  }
  if (tobject->byte_string_map != NULL)
  {
    g_hash_table_destroy (tobject->byte_string_map);
    tobject->byte_string_map = NULL;
  }
  if (tobject->byte_binary_map != NULL)
  {
    g_hash_table_destroy (tobject->byte_binary_map);
    tobject->byte_binary_map = NULL;
  }
  if (tobject->byte_boolean_map != NULL)
  {
    g_hash_table_destroy (tobject->byte_boolean_map);
    tobject->byte_boolean_map = NULL;
  }
  if (tobject->list_byte_map != NULL)
  {
    g_hash_table_destroy (tobject->list_byte_map);
    tobject->list_byte_map = NULL;
  }
  if (tobject->set_byte_map != NULL)
  {
    g_hash_table_destroy (tobject->set_byte_map);
    tobject->set_byte_map = NULL;
  }
  if (tobject->map_byte_map != NULL)
  {
    g_hash_table_destroy (tobject->map_byte_map);
    tobject->map_byte_map = NULL;
  }
  if (tobject->byte_map_map != NULL)
  {
    g_hash_table_destroy (tobject->byte_map_map);
    tobject->byte_map_map = NULL;
  }
  if (tobject->byte_set_map != NULL)
  {
    g_hash_table_destroy (tobject->byte_set_map);
    tobject->byte_set_map = NULL;
  }
  if (tobject->byte_list_map != NULL)
  {
    g_hash_table_destroy (tobject->byte_list_map);
    tobject->byte_list_map = NULL;
  }
}

static void 
t_test_compact_proto_test_struct_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_compact_proto_test_struct_finalize;
  cls->read = t_test_compact_proto_test_struct_read;
  cls->write = t_test_compact_proto_test_struct_write;
}

GType
t_test_compact_proto_test_struct_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestCompactProtoTestStructClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_compact_proto_test_struct_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestCompactProtoTestStruct),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_compact_proto_test_struct_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestCompactProtoTestStructType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a single_map_test_struct object */
static gint32
t_test_single_map_test_struct_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestSingleMapTestStruct * this_object = T_TEST_SINGLE_MAP_TEST_STRUCT(object);
  gboolean isset_i32_map = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint32* key98 = g_new (gint32, 1);
              gint32* val99 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*key98, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_i32 (protocol, &*val99, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->i32_map, (gpointer) key98, (gpointer) val99);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_i32_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_i32_map)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_test_single_map_test_struct_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestSingleMapTestStruct * this_object = T_TEST_SINGLE_MAP_TEST_STRUCT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SingleMapTestStruct", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i32_map", T_MAP, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_I32, (gint32) g_hash_table_size ((GHashTable *) this_object->i32_map), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gint32* key;
    gint32* value;
    g_hash_table_foreach ((GHashTable *) this_object->i32_map, thrift_hash_table_get_keys, &key_list);
    gint32* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gint32*) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (gint32*) g_hash_table_lookup (((GHashTable *) this_object->i32_map), (gpointer) key);

      if ((ret = thrift_protocol_write_i32 (protocol, * key, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_i32 (protocol, * value, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_single_map_test_struct_instance_init (TTestSingleMapTestStruct * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->i32_map = g_hash_table_new_full (g_int_hash, g_int_equal, NULL, NULL);
}

static void 
t_test_single_map_test_struct_finalize (GObject *object)
{
  TTestSingleMapTestStruct *tobject = T_TEST_SINGLE_MAP_TEST_STRUCT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->i32_map != NULL)
  {
    g_hash_table_destroy (tobject->i32_map);
    tobject->i32_map = NULL;
  }
}

static void 
t_test_single_map_test_struct_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_single_map_test_struct_finalize;
  cls->read = t_test_single_map_test_struct_read;
  cls->write = t_test_single_map_test_struct_write;
}

GType
t_test_single_map_test_struct_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestSingleMapTestStructClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_single_map_test_struct_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestSingleMapTestStruct),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_single_map_test_struct_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestSingleMapTestStructType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a exception_with_a_map object */
static gint32
t_test_exception_with_a_map_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestExceptionWithAMap * this_object = T_TEST_EXCEPTION_WITH_A_MAP(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->blah != NULL)
          {
            g_free(this_object->blah);
            this_object->blah = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->blah, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_blah = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gchar * key100 = NULL;
              gchar * val101 = NULL;
              if (key100 != NULL)
              {
                g_free(key100);
                key100 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key100, error)) < 0)
                return -1;
              xfer += ret;
              if (val101 != NULL)
              {
                g_free(val101);
                val101 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val101, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->map_field, (gpointer) key100, (gpointer) val101);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_map_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_exception_with_a_map_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestExceptionWithAMap * this_object = T_TEST_EXCEPTION_WITH_A_MAP(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ExceptionWithAMap", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "blah", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->blah, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "map_field", T_MAP, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, (gint32) g_hash_table_size ((GHashTable *) this_object->map_field), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gchar * key;
    gchar * value;
    g_hash_table_foreach ((GHashTable *) this_object->map_field, thrift_hash_table_get_keys, &key_list);
    gchar * keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gchar *) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->map_field), (gpointer) key);

      if ((ret = thrift_protocol_write_string (protocol,  key, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_string (protocol,  value, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_exception_with_a_map_instance_init (TTestExceptionWithAMap * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->blah = NULL;
  object->__isset_blah = FALSE;
  object->map_field = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_map_field = FALSE;
}

static void 
t_test_exception_with_a_map_finalize (GObject *object)
{
  TTestExceptionWithAMap *tobject = T_TEST_EXCEPTION_WITH_A_MAP (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->blah != NULL)
  {
    g_free (tobject->blah);
    tobject->blah = NULL;
  }
  if (tobject->map_field != NULL)
  {
    g_hash_table_destroy (tobject->map_field);
    tobject->map_field = NULL;
  }
}

static void 
t_test_exception_with_a_map_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_exception_with_a_map_finalize;
  cls->read = t_test_exception_with_a_map_read;
  cls->write = t_test_exception_with_a_map_write;
}

GType
t_test_exception_with_a_map_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestExceptionWithAMapClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_exception_with_a_map_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestExceptionWithAMap),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_exception_with_a_map_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestExceptionWithAMapType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define T_TEST_EXCEPTION_WITH_A_MAP_ERROR_DOMAIN "t_test_exception_with_a_map_error_quark"
GQuark
t_test_exception_with_a_map_error_quark (void)
{
  return g_quark_from_static_string (T_TEST_EXCEPTION_WITH_A_MAP_ERROR_DOMAIN);
}

/* reads a blow_up object */
static gint32
t_test_blow_up_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestBlowUp * this_object = T_TEST_BLOW_UP(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              GArray * key102 = NULL;
              GHashTable * val103 = NULL;
              {
                guint32 size;
                ThriftType element_type;
                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                guint32 i;
                for (i = 0; i < size; i++)
                {
                  gint32* _elem104 = g_new (gint32, 1);
                  if ((ret = thrift_protocol_read_i32 (protocol, &*_elem104, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_array_append_vals (key102, _elem104, 1);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;

              }
              {
                guint32 size;
                ThriftType element_type;
                if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through the set elements */
                guint32 i;
                for (i = 0; i < size; ++i)
                {
                  GHashTable * _elem105 = g_hash_table_new (NULL, NULL);
                  {
                    guint32 size;
                    ThriftType key_type;
                    ThriftType value_type;

                    /* read the map begin marker */
                    if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                      return -1;
                    xfer += ret;

                    /* iterate through each of the map's fields */
                    guint32 i;
                    for (i = 0; i < size; i++)
                    {
                      gint32* key106 = g_new (gint32, 1);
                      gchar * val107 = NULL;
                      if ((ret = thrift_protocol_read_i32 (protocol, &*key106, error)) < 0)
                        return -1;
                      xfer += ret;
                      if (val107 != NULL)
                      {
                        g_free(val107);
                        val107 = NULL;
                      }

                      if ((ret = thrift_protocol_read_string (protocol, &val107, error)) < 0)
                        return -1;
                      xfer += ret;
                      g_hash_table_insert ((GHashTable *)_elem105, (gpointer) key106, (gpointer) val107);
                    }

                    /* read the map end marker */
                    if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                      return -1;
                    xfer += ret;
                  }
                  g_hash_table_insert ((GHashTable *) val103, (gpointer) _elem105, (gpointer) 1);
                }
                if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;

              }
              g_hash_table_insert ((GHashTable *)this_object->b1, (gpointer) key102, (gpointer) val103);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_b1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              GArray * key108 = NULL;
              GHashTable * val109 = NULL;
              {
                guint32 size;
                ThriftType element_type;
                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                guint32 i;
                for (i = 0; i < size; i++)
                {
                  gint32* _elem110 = g_new (gint32, 1);
                  if ((ret = thrift_protocol_read_i32 (protocol, &*_elem110, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_array_append_vals (key108, _elem110, 1);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;

              }
              {
                guint32 size;
                ThriftType element_type;
                if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through the set elements */
                guint32 i;
                for (i = 0; i < size; ++i)
                {
                  GHashTable * _elem111 = g_hash_table_new (NULL, NULL);
                  {
                    guint32 size;
                    ThriftType key_type;
                    ThriftType value_type;

                    /* read the map begin marker */
                    if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                      return -1;
                    xfer += ret;

                    /* iterate through each of the map's fields */
                    guint32 i;
                    for (i = 0; i < size; i++)
                    {
                      gint32* key112 = g_new (gint32, 1);
                      gchar * val113 = NULL;
                      if ((ret = thrift_protocol_read_i32 (protocol, &*key112, error)) < 0)
                        return -1;
                      xfer += ret;
                      if (val113 != NULL)
                      {
                        g_free(val113);
                        val113 = NULL;
                      }

                      if ((ret = thrift_protocol_read_string (protocol, &val113, error)) < 0)
                        return -1;
                      xfer += ret;
                      g_hash_table_insert ((GHashTable *)_elem111, (gpointer) key112, (gpointer) val113);
                    }

                    /* read the map end marker */
                    if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                      return -1;
                    xfer += ret;
                  }
                  g_hash_table_insert ((GHashTable *) val109, (gpointer) _elem111, (gpointer) 1);
                }
                if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;

              }
              g_hash_table_insert ((GHashTable *)this_object->b2, (gpointer) key108, (gpointer) val109);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_b2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              GArray * key114 = NULL;
              GHashTable * val115 = NULL;
              {
                guint32 size;
                ThriftType element_type;
                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                guint32 i;
                for (i = 0; i < size; i++)
                {
                  gint32* _elem116 = g_new (gint32, 1);
                  if ((ret = thrift_protocol_read_i32 (protocol, &*_elem116, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_array_append_vals (key114, _elem116, 1);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;

              }
              {
                guint32 size;
                ThriftType element_type;
                if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through the set elements */
                guint32 i;
                for (i = 0; i < size; ++i)
                {
                  GHashTable * _elem117 = g_hash_table_new (NULL, NULL);
                  {
                    guint32 size;
                    ThriftType key_type;
                    ThriftType value_type;

                    /* read the map begin marker */
                    if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                      return -1;
                    xfer += ret;

                    /* iterate through each of the map's fields */
                    guint32 i;
                    for (i = 0; i < size; i++)
                    {
                      gint32* key118 = g_new (gint32, 1);
                      gchar * val119 = NULL;
                      if ((ret = thrift_protocol_read_i32 (protocol, &*key118, error)) < 0)
                        return -1;
                      xfer += ret;
                      if (val119 != NULL)
                      {
                        g_free(val119);
                        val119 = NULL;
                      }

                      if ((ret = thrift_protocol_read_string (protocol, &val119, error)) < 0)
                        return -1;
                      xfer += ret;
                      g_hash_table_insert ((GHashTable *)_elem117, (gpointer) key118, (gpointer) val119);
                    }

                    /* read the map end marker */
                    if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                      return -1;
                    xfer += ret;
                  }
                  g_hash_table_insert ((GHashTable *) val115, (gpointer) _elem117, (gpointer) 1);
                }
                if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;

              }
              g_hash_table_insert ((GHashTable *)this_object->b3, (gpointer) key114, (gpointer) val115);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_b3 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              GArray * key120 = NULL;
              GHashTable * val121 = NULL;
              {
                guint32 size;
                ThriftType element_type;
                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                guint32 i;
                for (i = 0; i < size; i++)
                {
                  gint32* _elem122 = g_new (gint32, 1);
                  if ((ret = thrift_protocol_read_i32 (protocol, &*_elem122, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_array_append_vals (key120, _elem122, 1);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;

              }
              {
                guint32 size;
                ThriftType element_type;
                if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through the set elements */
                guint32 i;
                for (i = 0; i < size; ++i)
                {
                  GHashTable * _elem123 = g_hash_table_new (NULL, NULL);
                  {
                    guint32 size;
                    ThriftType key_type;
                    ThriftType value_type;

                    /* read the map begin marker */
                    if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                      return -1;
                    xfer += ret;

                    /* iterate through each of the map's fields */
                    guint32 i;
                    for (i = 0; i < size; i++)
                    {
                      gint32* key124 = g_new (gint32, 1);
                      gchar * val125 = NULL;
                      if ((ret = thrift_protocol_read_i32 (protocol, &*key124, error)) < 0)
                        return -1;
                      xfer += ret;
                      if (val125 != NULL)
                      {
                        g_free(val125);
                        val125 = NULL;
                      }

                      if ((ret = thrift_protocol_read_string (protocol, &val125, error)) < 0)
                        return -1;
                      xfer += ret;
                      g_hash_table_insert ((GHashTable *)_elem123, (gpointer) key124, (gpointer) val125);
                    }

                    /* read the map end marker */
                    if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                      return -1;
                    xfer += ret;
                  }
                  g_hash_table_insert ((GHashTable *) val121, (gpointer) _elem123, (gpointer) 1);
                }
                if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;

              }
              g_hash_table_insert ((GHashTable *)this_object->b4, (gpointer) key120, (gpointer) val121);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_b4 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_blow_up_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestBlowUp * this_object = T_TEST_BLOW_UP(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BlowUp", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "b1", T_MAP, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_LIST, T_SET, (gint32) g_hash_table_size ((GHashTable *) this_object->b1), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    GArray * key;
    GHashTable * value;
    g_hash_table_foreach ((GHashTable *) this_object->b1, thrift_hash_table_get_keys, &key_list);
    GArray * keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (GArray *) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (GHashTable *) g_hash_table_lookup (((GHashTable *) this_object->b1), (gpointer) key);

      {
        if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32)  key->len, error)) < 0)
          return -1;
        xfer += ret;
        guint i126;
        for (i126=0; i126< key->len; i126++)
        {
          if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index ( key, gint32, i126)), error)) < 0)
            return -1;
        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
      {
        if ((ret = thrift_protocol_write_set_begin (protocol, T_MAP, (gint32) g_hash_table_size ((GHashTable *)  value), error)) < 0)
          return -1;
        xfer += ret;
        GList *key_list = NULL, *iter = NULL;
        GHashTable * elem;
        gpointer value;
        THRIFT_UNUSED_VAR (value);

        g_hash_table_foreach ((GHashTable *)  value, thrift_hash_table_get_keys, &key_list);
        GHashTable * keys[g_list_length (key_list)];
        int i=0, key_count = g_list_length (key_list);
        for (iter = g_list_first (key_list); iter; iter = iter->next)
        {
          keys[i++] = (GHashTable *) iter->data;
        }
        g_list_free (key_list);

        for (i=0; i<key_count; ++i)
        {
          elem = keys[i];
          value = (gpointer) g_hash_table_lookup (((GHashTable *)  value), (gpointer) elem);

          {
            if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_STRING, (gint32) g_hash_table_size ((GHashTable *) elem), error)) < 0)
              return -1;
            xfer += ret;

            GList *key_list = NULL, *iter = NULL;
            gint32* key;
            gchar * value;
            g_hash_table_foreach ((GHashTable *) elem, thrift_hash_table_get_keys, &key_list);
            gint32* keys[g_list_length (key_list)];
            int i=0, key_count = g_list_length (key_list);
            for (iter = g_list_first (key_list); iter; iter = iter->next)
            {
              keys[i++] = (gint32*) iter->data;
            }
            g_list_free (key_list);

            for (i = 0; i < key_count; ++i)
            {
              key = keys[i];
              value = (gchar *) g_hash_table_lookup (((GHashTable *) elem), (gpointer) key);

              if ((ret = thrift_protocol_write_i32 (protocol, * key, error)) < 0)
                return -1;
              if ((ret = thrift_protocol_write_string (protocol,  value, error)) < 0)
                return -1;
            }
            if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
        }
        if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "b2", T_MAP, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_LIST, T_SET, (gint32) g_hash_table_size ((GHashTable *) this_object->b2), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    GArray * key;
    GHashTable * value;
    g_hash_table_foreach ((GHashTable *) this_object->b2, thrift_hash_table_get_keys, &key_list);
    GArray * keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (GArray *) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (GHashTable *) g_hash_table_lookup (((GHashTable *) this_object->b2), (gpointer) key);

      {
        if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32)  key->len, error)) < 0)
          return -1;
        xfer += ret;
        guint i127;
        for (i127=0; i127< key->len; i127++)
        {
          if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index ( key, gint32, i127)), error)) < 0)
            return -1;
        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
      {
        if ((ret = thrift_protocol_write_set_begin (protocol, T_MAP, (gint32) g_hash_table_size ((GHashTable *)  value), error)) < 0)
          return -1;
        xfer += ret;
        GList *key_list = NULL, *iter = NULL;
        GHashTable * elem;
        gpointer value;
        THRIFT_UNUSED_VAR (value);

        g_hash_table_foreach ((GHashTable *)  value, thrift_hash_table_get_keys, &key_list);
        GHashTable * keys[g_list_length (key_list)];
        int i=0, key_count = g_list_length (key_list);
        for (iter = g_list_first (key_list); iter; iter = iter->next)
        {
          keys[i++] = (GHashTable *) iter->data;
        }
        g_list_free (key_list);

        for (i=0; i<key_count; ++i)
        {
          elem = keys[i];
          value = (gpointer) g_hash_table_lookup (((GHashTable *)  value), (gpointer) elem);

          {
            if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_STRING, (gint32) g_hash_table_size ((GHashTable *) elem), error)) < 0)
              return -1;
            xfer += ret;

            GList *key_list = NULL, *iter = NULL;
            gint32* key;
            gchar * value;
            g_hash_table_foreach ((GHashTable *) elem, thrift_hash_table_get_keys, &key_list);
            gint32* keys[g_list_length (key_list)];
            int i=0, key_count = g_list_length (key_list);
            for (iter = g_list_first (key_list); iter; iter = iter->next)
            {
              keys[i++] = (gint32*) iter->data;
            }
            g_list_free (key_list);

            for (i = 0; i < key_count; ++i)
            {
              key = keys[i];
              value = (gchar *) g_hash_table_lookup (((GHashTable *) elem), (gpointer) key);

              if ((ret = thrift_protocol_write_i32 (protocol, * key, error)) < 0)
                return -1;
              if ((ret = thrift_protocol_write_string (protocol,  value, error)) < 0)
                return -1;
            }
            if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
        }
        if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "b3", T_MAP, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_LIST, T_SET, (gint32) g_hash_table_size ((GHashTable *) this_object->b3), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    GArray * key;
    GHashTable * value;
    g_hash_table_foreach ((GHashTable *) this_object->b3, thrift_hash_table_get_keys, &key_list);
    GArray * keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (GArray *) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (GHashTable *) g_hash_table_lookup (((GHashTable *) this_object->b3), (gpointer) key);

      {
        if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32)  key->len, error)) < 0)
          return -1;
        xfer += ret;
        guint i128;
        for (i128=0; i128< key->len; i128++)
        {
          if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index ( key, gint32, i128)), error)) < 0)
            return -1;
        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
      {
        if ((ret = thrift_protocol_write_set_begin (protocol, T_MAP, (gint32) g_hash_table_size ((GHashTable *)  value), error)) < 0)
          return -1;
        xfer += ret;
        GList *key_list = NULL, *iter = NULL;
        GHashTable * elem;
        gpointer value;
        THRIFT_UNUSED_VAR (value);

        g_hash_table_foreach ((GHashTable *)  value, thrift_hash_table_get_keys, &key_list);
        GHashTable * keys[g_list_length (key_list)];
        int i=0, key_count = g_list_length (key_list);
        for (iter = g_list_first (key_list); iter; iter = iter->next)
        {
          keys[i++] = (GHashTable *) iter->data;
        }
        g_list_free (key_list);

        for (i=0; i<key_count; ++i)
        {
          elem = keys[i];
          value = (gpointer) g_hash_table_lookup (((GHashTable *)  value), (gpointer) elem);

          {
            if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_STRING, (gint32) g_hash_table_size ((GHashTable *) elem), error)) < 0)
              return -1;
            xfer += ret;

            GList *key_list = NULL, *iter = NULL;
            gint32* key;
            gchar * value;
            g_hash_table_foreach ((GHashTable *) elem, thrift_hash_table_get_keys, &key_list);
            gint32* keys[g_list_length (key_list)];
            int i=0, key_count = g_list_length (key_list);
            for (iter = g_list_first (key_list); iter; iter = iter->next)
            {
              keys[i++] = (gint32*) iter->data;
            }
            g_list_free (key_list);

            for (i = 0; i < key_count; ++i)
            {
              key = keys[i];
              value = (gchar *) g_hash_table_lookup (((GHashTable *) elem), (gpointer) key);

              if ((ret = thrift_protocol_write_i32 (protocol, * key, error)) < 0)
                return -1;
              if ((ret = thrift_protocol_write_string (protocol,  value, error)) < 0)
                return -1;
            }
            if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
        }
        if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "b4", T_MAP, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_LIST, T_SET, (gint32) g_hash_table_size ((GHashTable *) this_object->b4), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    GArray * key;
    GHashTable * value;
    g_hash_table_foreach ((GHashTable *) this_object->b4, thrift_hash_table_get_keys, &key_list);
    GArray * keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (GArray *) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (GHashTable *) g_hash_table_lookup (((GHashTable *) this_object->b4), (gpointer) key);

      {
        if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32)  key->len, error)) < 0)
          return -1;
        xfer += ret;
        guint i129;
        for (i129=0; i129< key->len; i129++)
        {
          if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index ( key, gint32, i129)), error)) < 0)
            return -1;
        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
      {
        if ((ret = thrift_protocol_write_set_begin (protocol, T_MAP, (gint32) g_hash_table_size ((GHashTable *)  value), error)) < 0)
          return -1;
        xfer += ret;
        GList *key_list = NULL, *iter = NULL;
        GHashTable * elem;
        gpointer value;
        THRIFT_UNUSED_VAR (value);

        g_hash_table_foreach ((GHashTable *)  value, thrift_hash_table_get_keys, &key_list);
        GHashTable * keys[g_list_length (key_list)];
        int i=0, key_count = g_list_length (key_list);
        for (iter = g_list_first (key_list); iter; iter = iter->next)
        {
          keys[i++] = (GHashTable *) iter->data;
        }
        g_list_free (key_list);

        for (i=0; i<key_count; ++i)
        {
          elem = keys[i];
          value = (gpointer) g_hash_table_lookup (((GHashTable *)  value), (gpointer) elem);

          {
            if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_STRING, (gint32) g_hash_table_size ((GHashTable *) elem), error)) < 0)
              return -1;
            xfer += ret;

            GList *key_list = NULL, *iter = NULL;
            gint32* key;
            gchar * value;
            g_hash_table_foreach ((GHashTable *) elem, thrift_hash_table_get_keys, &key_list);
            gint32* keys[g_list_length (key_list)];
            int i=0, key_count = g_list_length (key_list);
            for (iter = g_list_first (key_list); iter; iter = iter->next)
            {
              keys[i++] = (gint32*) iter->data;
            }
            g_list_free (key_list);

            for (i = 0; i < key_count; ++i)
            {
              key = keys[i];
              value = (gchar *) g_hash_table_lookup (((GHashTable *) elem), (gpointer) key);

              if ((ret = thrift_protocol_write_i32 (protocol, * key, error)) < 0)
                return -1;
              if ((ret = thrift_protocol_write_string (protocol,  value, error)) < 0)
                return -1;
            }
            if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
        }
        if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_blow_up_instance_init (TTestBlowUp * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->b1 = g_hash_table_new_full (g_direct_hash, g_direct_equal, (GDestroyNotify) g_array_unref, (GDestroyNotify) g_hash_table_destroy);
  object->__isset_b1 = FALSE;
  object->b2 = g_hash_table_new_full (g_direct_hash, g_direct_equal, (GDestroyNotify) g_array_unref, (GDestroyNotify) g_hash_table_destroy);
  object->__isset_b2 = FALSE;
  object->b3 = g_hash_table_new_full (g_direct_hash, g_direct_equal, (GDestroyNotify) g_array_unref, (GDestroyNotify) g_hash_table_destroy);
  object->__isset_b3 = FALSE;
  object->b4 = g_hash_table_new_full (g_direct_hash, g_direct_equal, (GDestroyNotify) g_array_unref, (GDestroyNotify) g_hash_table_destroy);
  object->__isset_b4 = FALSE;
}

static void 
t_test_blow_up_finalize (GObject *object)
{
  TTestBlowUp *tobject = T_TEST_BLOW_UP (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->b1 != NULL)
  {
    g_hash_table_destroy (tobject->b1);
    tobject->b1 = NULL;
  }
  if (tobject->b2 != NULL)
  {
    g_hash_table_destroy (tobject->b2);
    tobject->b2 = NULL;
  }
  if (tobject->b3 != NULL)
  {
    g_hash_table_destroy (tobject->b3);
    tobject->b3 = NULL;
  }
  if (tobject->b4 != NULL)
  {
    g_hash_table_destroy (tobject->b4);
    tobject->b4 = NULL;
  }
}

static void 
t_test_blow_up_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_blow_up_finalize;
  cls->read = t_test_blow_up_read;
  cls->write = t_test_blow_up_write;
}

GType
t_test_blow_up_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestBlowUpClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_blow_up_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestBlowUp),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_blow_up_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestBlowUpType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a reverse_order_struct object */
static gint32
t_test_reverse_order_struct_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestReverseOrderStruct * this_object = T_TEST_REVERSE_ORDER_STRUCT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->first != NULL)
          {
            g_free(this_object->first);
            this_object->first = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->first, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_first = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->second, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_second = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->third, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_third = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->fourth, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_fourth = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_reverse_order_struct_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestReverseOrderStruct * this_object = T_TEST_REVERSE_ORDER_STRUCT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ReverseOrderStruct", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "first", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->first, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "second", T_I16, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->second, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "third", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->third, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "fourth", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->fourth, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_reverse_order_struct_instance_init (TTestReverseOrderStruct * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->first = NULL;
  object->__isset_first = FALSE;
  object->second = 0;
  object->__isset_second = FALSE;
  object->third = 0;
  object->__isset_third = FALSE;
  object->fourth = 0;
  object->__isset_fourth = FALSE;
}

static void 
t_test_reverse_order_struct_finalize (GObject *object)
{
  TTestReverseOrderStruct *tobject = T_TEST_REVERSE_ORDER_STRUCT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->first != NULL)
  {
    g_free (tobject->first);
    tobject->first = NULL;
  }
}

static void 
t_test_reverse_order_struct_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_reverse_order_struct_finalize;
  cls->read = t_test_reverse_order_struct_read;
  cls->write = t_test_reverse_order_struct_write;
}

GType
t_test_reverse_order_struct_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestReverseOrderStructClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_reverse_order_struct_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestReverseOrderStruct),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_reverse_order_struct_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestReverseOrderStructType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a struct_with_some_enum object */
static gint32
t_test_struct_with_some_enum_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestStructWithSomeEnum * this_object = T_TEST_STRUCT_WITH_SOME_ENUM(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast130;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast130, error)) < 0)
            return -1;
          xfer += ret;
          this_object->blah = (TTestSomeEnum)ecast130;
          this_object->__isset_blah = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_struct_with_some_enum_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestStructWithSomeEnum * this_object = T_TEST_STRUCT_WITH_SOME_ENUM(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "StructWithSomeEnum", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "blah", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->blah, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_struct_with_some_enum_instance_init (TTestStructWithSomeEnum * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_blah = FALSE;
}

static void 
t_test_struct_with_some_enum_finalize (GObject *object)
{
  TTestStructWithSomeEnum *tobject = T_TEST_STRUCT_WITH_SOME_ENUM (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void 
t_test_struct_with_some_enum_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_struct_with_some_enum_finalize;
  cls->read = t_test_struct_with_some_enum_read;
  cls->write = t_test_struct_with_some_enum_write;
}

GType
t_test_struct_with_some_enum_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestStructWithSomeEnumClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_struct_with_some_enum_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestStructWithSomeEnum),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_struct_with_some_enum_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestStructWithSomeEnumType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a test_union object */
static gint32
t_test_test_union_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestTestUnion * this_object = T_TEST_TEST_UNION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->string_field != NULL)
          {
            g_free(this_object->string_field);
            this_object->string_field = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->string_field, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_string_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->i32_field, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_i32_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->struct_field), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_struct_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              TTestRandomStuff * _elem131 = NULL;
              if ( _elem131 != NULL)
              {
                g_object_unref (_elem131);
              }
              _elem131 = g_object_new (T_TEST_TYPE_RANDOM_STUFF, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem131), protocol, error)) < 0)
              {
                g_object_unref (_elem131);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->struct_list, _elem131);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_struct_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->other_i32_field, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_other_i32_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          gint32 ecast132;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast132, error)) < 0)
            return -1;
          xfer += ret;
          this_object->enum_field = (TTestSomeEnum)ecast132;
          this_object->__isset_enum_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            guint32 i;
            for (i = 0; i < size; ++i)
            {
              gint32* _elem133 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem133, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *) this_object->i32_set, (gpointer) _elem133, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_i32_set = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint32* key134 = g_new (gint32, 1);
              gint32* val135 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*key134, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_i32 (protocol, &*val135, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->i32_map, (gpointer) key134, (gpointer) val135);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_i32_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_test_union_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestTestUnion * this_object = T_TEST_TEST_UNION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TestUnion", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "string_field", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->string_field, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i32_field", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->i32_field, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "struct_field", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->struct_field), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "struct_list", T_LIST, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->struct_list->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i136;
    for (i136=0; i136<this_object->struct_list->len; i136++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->struct_list, i136))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "other_i32_field", T_I32, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->other_i32_field, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "enum_field", T_I32, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->enum_field, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i32_set", T_SET, 7, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_set_begin (protocol, T_I32, (gint32) g_hash_table_size ((GHashTable *) this_object->i32_set), error)) < 0)
      return -1;
    xfer += ret;
    GList *key_list = NULL, *iter = NULL;
    gint32* elem;
    gpointer value;
    THRIFT_UNUSED_VAR (value);

    g_hash_table_foreach ((GHashTable *) this_object->i32_set, thrift_hash_table_get_keys, &key_list);
    gint32* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gint32*) iter->data;
    }
    g_list_free (key_list);

    for (i=0; i<key_count; ++i)
    {
      elem = keys[i];
      value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->i32_set), (gpointer) elem);

      if ((ret = thrift_protocol_write_i32 (protocol, *elem, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i32_map", T_MAP, 8, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_I32, (gint32) g_hash_table_size ((GHashTable *) this_object->i32_map), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gint32* key;
    gint32* value;
    g_hash_table_foreach ((GHashTable *) this_object->i32_map, thrift_hash_table_get_keys, &key_list);
    gint32* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gint32*) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (gint32*) g_hash_table_lookup (((GHashTable *) this_object->i32_map), (gpointer) key);

      if ((ret = thrift_protocol_write_i32 (protocol, * key, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_i32 (protocol, * value, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_test_union_instance_init (TTestTestUnion * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->string_field = NULL;
  object->__isset_string_field = FALSE;
  object->i32_field = 0;
  object->__isset_i32_field = FALSE;
  object->struct_field = g_object_new (T_TEST_TYPE_ONE_OF_EACH, NULL);
  object->__isset_struct_field = FALSE;
  object->struct_list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_struct_list = FALSE;
  object->other_i32_field = 0;
  object->__isset_other_i32_field = FALSE;
  object->__isset_enum_field = FALSE;
  object->i32_set = g_hash_table_new_full (g_int_hash, g_int_equal, NULL, NULL);
  object->__isset_i32_set = FALSE;
  object->i32_map = g_hash_table_new_full (g_int_hash, g_int_equal, NULL, NULL);
  object->__isset_i32_map = FALSE;
}

static void 
t_test_test_union_finalize (GObject *object)
{
  TTestTestUnion *tobject = T_TEST_TEST_UNION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->string_field != NULL)
  {
    g_free (tobject->string_field);
    tobject->string_field = NULL;
  }
  if (tobject->struct_field != NULL)
  {
    g_object_unref(tobject->struct_field);
    tobject->struct_field = NULL;
  }
  if (tobject->struct_list != NULL)
  {
    g_ptr_array_free (tobject->struct_list, TRUE);
    tobject->struct_list = NULL;
  }
  if (tobject->i32_set != NULL)
  {
    g_hash_table_destroy (tobject->i32_set);
    tobject->i32_set = NULL;
  }
  if (tobject->i32_map != NULL)
  {
    g_hash_table_destroy (tobject->i32_map);
    tobject->i32_map = NULL;
  }
}

static void 
t_test_test_union_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_test_union_finalize;
  cls->read = t_test_test_union_read;
  cls->write = t_test_test_union_write;
}

GType
t_test_test_union_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestTestUnionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_test_union_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestTestUnion),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_test_union_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestTestUnionType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a test_union_minus_string_field object */
static gint32
t_test_test_union_minus_string_field_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestTestUnionMinusStringField * this_object = T_TEST_TEST_UNION_MINUS_STRING_FIELD(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->i32_field, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_i32_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->struct_field), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_struct_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              TTestRandomStuff * _elem137 = NULL;
              if ( _elem137 != NULL)
              {
                g_object_unref (_elem137);
              }
              _elem137 = g_object_new (T_TEST_TYPE_RANDOM_STUFF, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem137), protocol, error)) < 0)
              {
                g_object_unref (_elem137);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->struct_list, _elem137);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_struct_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->other_i32_field, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_other_i32_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          gint32 ecast138;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast138, error)) < 0)
            return -1;
          xfer += ret;
          this_object->enum_field = (TTestSomeEnum)ecast138;
          this_object->__isset_enum_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            guint32 i;
            for (i = 0; i < size; ++i)
            {
              gint32* _elem139 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem139, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *) this_object->i32_set, (gpointer) _elem139, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_i32_set = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint32* key140 = g_new (gint32, 1);
              gint32* val141 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*key140, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_i32 (protocol, &*val141, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->i32_map, (gpointer) key140, (gpointer) val141);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_i32_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_test_union_minus_string_field_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestTestUnionMinusStringField * this_object = T_TEST_TEST_UNION_MINUS_STRING_FIELD(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TestUnionMinusStringField", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i32_field", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->i32_field, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "struct_field", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->struct_field), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "struct_list", T_LIST, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->struct_list->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i142;
    for (i142=0; i142<this_object->struct_list->len; i142++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->struct_list, i142))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "other_i32_field", T_I32, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->other_i32_field, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "enum_field", T_I32, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->enum_field, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i32_set", T_SET, 7, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_set_begin (protocol, T_I32, (gint32) g_hash_table_size ((GHashTable *) this_object->i32_set), error)) < 0)
      return -1;
    xfer += ret;
    GList *key_list = NULL, *iter = NULL;
    gint32* elem;
    gpointer value;
    THRIFT_UNUSED_VAR (value);

    g_hash_table_foreach ((GHashTable *) this_object->i32_set, thrift_hash_table_get_keys, &key_list);
    gint32* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gint32*) iter->data;
    }
    g_list_free (key_list);

    for (i=0; i<key_count; ++i)
    {
      elem = keys[i];
      value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->i32_set), (gpointer) elem);

      if ((ret = thrift_protocol_write_i32 (protocol, *elem, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i32_map", T_MAP, 8, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_I32, (gint32) g_hash_table_size ((GHashTable *) this_object->i32_map), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gint32* key;
    gint32* value;
    g_hash_table_foreach ((GHashTable *) this_object->i32_map, thrift_hash_table_get_keys, &key_list);
    gint32* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gint32*) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (gint32*) g_hash_table_lookup (((GHashTable *) this_object->i32_map), (gpointer) key);

      if ((ret = thrift_protocol_write_i32 (protocol, * key, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_i32 (protocol, * value, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_test_union_minus_string_field_instance_init (TTestTestUnionMinusStringField * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->i32_field = 0;
  object->__isset_i32_field = FALSE;
  object->struct_field = g_object_new (T_TEST_TYPE_ONE_OF_EACH, NULL);
  object->__isset_struct_field = FALSE;
  object->struct_list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_struct_list = FALSE;
  object->other_i32_field = 0;
  object->__isset_other_i32_field = FALSE;
  object->__isset_enum_field = FALSE;
  object->i32_set = g_hash_table_new_full (g_int_hash, g_int_equal, NULL, NULL);
  object->__isset_i32_set = FALSE;
  object->i32_map = g_hash_table_new_full (g_int_hash, g_int_equal, NULL, NULL);
  object->__isset_i32_map = FALSE;
}

static void 
t_test_test_union_minus_string_field_finalize (GObject *object)
{
  TTestTestUnionMinusStringField *tobject = T_TEST_TEST_UNION_MINUS_STRING_FIELD (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->struct_field != NULL)
  {
    g_object_unref(tobject->struct_field);
    tobject->struct_field = NULL;
  }
  if (tobject->struct_list != NULL)
  {
    g_ptr_array_free (tobject->struct_list, TRUE);
    tobject->struct_list = NULL;
  }
  if (tobject->i32_set != NULL)
  {
    g_hash_table_destroy (tobject->i32_set);
    tobject->i32_set = NULL;
  }
  if (tobject->i32_map != NULL)
  {
    g_hash_table_destroy (tobject->i32_map);
    tobject->i32_map = NULL;
  }
}

static void 
t_test_test_union_minus_string_field_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_test_union_minus_string_field_finalize;
  cls->read = t_test_test_union_minus_string_field_read;
  cls->write = t_test_test_union_minus_string_field_write;
}

GType
t_test_test_union_minus_string_field_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestTestUnionMinusStringFieldClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_test_union_minus_string_field_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestTestUnionMinusStringField),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_test_union_minus_string_field_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestTestUnionMinusStringFieldType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a comparable_union object */
static gint32
t_test_comparable_union_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestComparableUnion * this_object = T_TEST_COMPARABLE_UNION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->string_field != NULL)
          {
            g_free(this_object->string_field);
            this_object->string_field = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->string_field, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_string_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->binary_field != NULL)
          {
            g_free(this_object->binary_field);
            this_object->binary_field = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->binary_field = g_byte_array_new();
          g_byte_array_append (this_object->binary_field, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_binary_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_comparable_union_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestComparableUnion * this_object = T_TEST_COMPARABLE_UNION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ComparableUnion", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "string_field", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->string_field, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "binary_field", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->binary_field)->data, ((GByteArray *) this_object->binary_field)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_comparable_union_instance_init (TTestComparableUnion * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->string_field = NULL;
  object->__isset_string_field = FALSE;
  object->binary_field = NULL;
  object->__isset_binary_field = FALSE;
}

static void 
t_test_comparable_union_finalize (GObject *object)
{
  TTestComparableUnion *tobject = T_TEST_COMPARABLE_UNION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->string_field != NULL)
  {
    g_free (tobject->string_field);
    tobject->string_field = NULL;
  }
  if (tobject->binary_field != NULL)
  {
    g_free (tobject->binary_field);
    tobject->binary_field = NULL;
  }
}

static void 
t_test_comparable_union_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_comparable_union_finalize;
  cls->read = t_test_comparable_union_read;
  cls->write = t_test_comparable_union_write;
}

GType
t_test_comparable_union_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestComparableUnionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_comparable_union_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestComparableUnion),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_comparable_union_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestComparableUnionType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a struct_with_a_union object */
static gint32
t_test_struct_with_a_union_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestStructWithAUnion * this_object = T_TEST_STRUCT_WITH_A_UNION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->test_union), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_test_union = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_struct_with_a_union_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestStructWithAUnion * this_object = T_TEST_STRUCT_WITH_A_UNION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "StructWithAUnion", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "test_union", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->test_union), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_struct_with_a_union_instance_init (TTestStructWithAUnion * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->test_union = g_object_new (T_TEST_TYPE_TEST_UNION, NULL);
  object->__isset_test_union = FALSE;
}

static void 
t_test_struct_with_a_union_finalize (GObject *object)
{
  TTestStructWithAUnion *tobject = T_TEST_STRUCT_WITH_A_UNION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->test_union != NULL)
  {
    g_object_unref(tobject->test_union);
    tobject->test_union = NULL;
  }
}

static void 
t_test_struct_with_a_union_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_struct_with_a_union_finalize;
  cls->read = t_test_struct_with_a_union_read;
  cls->write = t_test_struct_with_a_union_write;
}

GType
t_test_struct_with_a_union_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestStructWithAUnionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_struct_with_a_union_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestStructWithAUnion),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_struct_with_a_union_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestStructWithAUnionType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a primitive_then_struct object */
static gint32
t_test_primitive_then_struct_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestPrimitiveThenStruct * this_object = T_TEST_PRIMITIVE_THEN_STRUCT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->blah, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_blah = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->blah2, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_blah2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->bw), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_bw = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_primitive_then_struct_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestPrimitiveThenStruct * this_object = T_TEST_PRIMITIVE_THEN_STRUCT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "PrimitiveThenStruct", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "blah", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->blah, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "blah2", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->blah2, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "bw", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->bw), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_primitive_then_struct_instance_init (TTestPrimitiveThenStruct * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->blah = 0;
  object->__isset_blah = FALSE;
  object->blah2 = 0;
  object->__isset_blah2 = FALSE;
  object->bw = g_object_new (T_TEST_TYPE_BACKWARDS, NULL);
  object->__isset_bw = FALSE;
}

static void 
t_test_primitive_then_struct_finalize (GObject *object)
{
  TTestPrimitiveThenStruct *tobject = T_TEST_PRIMITIVE_THEN_STRUCT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->bw != NULL)
  {
    g_object_unref(tobject->bw);
    tobject->bw = NULL;
  }
}

static void 
t_test_primitive_then_struct_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_primitive_then_struct_finalize;
  cls->read = t_test_primitive_then_struct_read;
  cls->write = t_test_primitive_then_struct_write;
}

GType
t_test_primitive_then_struct_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestPrimitiveThenStructClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_primitive_then_struct_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestPrimitiveThenStruct),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_primitive_then_struct_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestPrimitiveThenStructType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a struct_with_a_somemap object */
static gint32
t_test_struct_with_a_somemap_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestStructWithASomemap * this_object = T_TEST_STRUCT_WITH_A_SOMEMAP(object);
  gboolean isset_somemap_field = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint32* key143 = g_new (gint32, 1);
              gint32* val144 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*key143, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_i32 (protocol, &*val144, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->somemap_field, (gpointer) key143, (gpointer) val144);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_somemap_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_somemap_field)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_test_struct_with_a_somemap_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestStructWithASomemap * this_object = T_TEST_STRUCT_WITH_A_SOMEMAP(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "StructWithASomemap", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "somemap_field", T_MAP, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_I32, (gint32) g_hash_table_size ((GHashTable *) this_object->somemap_field), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gint32* key;
    gint32* value;
    g_hash_table_foreach ((GHashTable *) this_object->somemap_field, thrift_hash_table_get_keys, &key_list);
    gint32* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gint32*) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (gint32*) g_hash_table_lookup (((GHashTable *) this_object->somemap_field), (gpointer) key);

      if ((ret = thrift_protocol_write_i32 (protocol, * key, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_i32 (protocol, * value, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_struct_with_a_somemap_instance_init (TTestStructWithASomemap * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->somemap_field = g_hash_table_new_full (g_int_hash, g_int_equal, NULL, NULL);
}

static void 
t_test_struct_with_a_somemap_finalize (GObject *object)
{
  TTestStructWithASomemap *tobject = T_TEST_STRUCT_WITH_A_SOMEMAP (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->somemap_field != NULL)
  {
    g_hash_table_destroy (tobject->somemap_field);
    tobject->somemap_field = NULL;
  }
}

static void 
t_test_struct_with_a_somemap_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_struct_with_a_somemap_finalize;
  cls->read = t_test_struct_with_a_somemap_read;
  cls->write = t_test_struct_with_a_somemap_write;
}

GType
t_test_struct_with_a_somemap_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestStructWithASomemapClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_struct_with_a_somemap_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestStructWithASomemap),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_struct_with_a_somemap_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestStructWithASomemapType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a big_field_id_struct object */
static gint32
t_test_big_field_id_struct_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestBigFieldIdStruct * this_object = T_TEST_BIG_FIELD_ID_STRUCT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->field1 != NULL)
          {
            g_free(this_object->field1);
            this_object->field1 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->field1, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 45:
        if (ftype == T_STRING)
        {
          if (this_object->field2 != NULL)
          {
            g_free(this_object->field2);
            this_object->field2 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->field2, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_big_field_id_struct_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestBigFieldIdStruct * this_object = T_TEST_BIG_FIELD_ID_STRUCT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BigFieldIdStruct", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "field1", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->field1, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "field2", T_STRING, 45, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->field2, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_big_field_id_struct_instance_init (TTestBigFieldIdStruct * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->field1 = NULL;
  object->__isset_field1 = FALSE;
  object->field2 = NULL;
  object->__isset_field2 = FALSE;
}

static void 
t_test_big_field_id_struct_finalize (GObject *object)
{
  TTestBigFieldIdStruct *tobject = T_TEST_BIG_FIELD_ID_STRUCT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->field1 != NULL)
  {
    g_free (tobject->field1);
    tobject->field1 = NULL;
  }
  if (tobject->field2 != NULL)
  {
    g_free (tobject->field2);
    tobject->field2 = NULL;
  }
}

static void 
t_test_big_field_id_struct_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_big_field_id_struct_finalize;
  cls->read = t_test_big_field_id_struct_read;
  cls->write = t_test_big_field_id_struct_write;
}

GType
t_test_big_field_id_struct_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestBigFieldIdStructClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_big_field_id_struct_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestBigFieldIdStruct),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_big_field_id_struct_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestBigFieldIdStructType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a breaks_ruby_compact_protocol object */
static gint32
t_test_breaks_ruby_compact_protocol_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestBreaksRubyCompactProtocol * this_object = T_TEST_BREAKS_RUBY_COMPACT_PROTOCOL(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->field1 != NULL)
          {
            g_free(this_object->field1);
            this_object->field1 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->field1, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->field2), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_field2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field3, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field3 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_breaks_ruby_compact_protocol_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestBreaksRubyCompactProtocol * this_object = T_TEST_BREAKS_RUBY_COMPACT_PROTOCOL(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BreaksRubyCompactProtocol", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "field1", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->field1, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "field2", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->field2), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "field3", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->field3, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_breaks_ruby_compact_protocol_instance_init (TTestBreaksRubyCompactProtocol * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->field1 = NULL;
  object->__isset_field1 = FALSE;
  object->field2 = g_object_new (T_TEST_TYPE_BIG_FIELD_ID_STRUCT, NULL);
  object->__isset_field2 = FALSE;
  object->field3 = 0;
  object->__isset_field3 = FALSE;
}

static void 
t_test_breaks_ruby_compact_protocol_finalize (GObject *object)
{
  TTestBreaksRubyCompactProtocol *tobject = T_TEST_BREAKS_RUBY_COMPACT_PROTOCOL (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->field1 != NULL)
  {
    g_free (tobject->field1);
    tobject->field1 = NULL;
  }
  if (tobject->field2 != NULL)
  {
    g_object_unref(tobject->field2);
    tobject->field2 = NULL;
  }
}

static void 
t_test_breaks_ruby_compact_protocol_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_breaks_ruby_compact_protocol_finalize;
  cls->read = t_test_breaks_ruby_compact_protocol_read;
  cls->write = t_test_breaks_ruby_compact_protocol_write;
}

GType
t_test_breaks_ruby_compact_protocol_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestBreaksRubyCompactProtocolClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_breaks_ruby_compact_protocol_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestBreaksRubyCompactProtocol),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_breaks_ruby_compact_protocol_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestBreaksRubyCompactProtocolType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a tuple_protocol_test_struct object */
static gint32
t_test_tuple_protocol_test_struct_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestTupleProtocolTestStruct * this_object = T_TEST_TUPLE_PROTOCOL_TEST_STRUCT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case -1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field1, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case -2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field2, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case -3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field3, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field3 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case -4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field4, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field4 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case -5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field5, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field5 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case -6:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field6, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field6 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case -7:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field7, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field7 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case -8:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field8, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field8 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case -9:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field9, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field9 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case -10:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field10, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field10 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case -11:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field11, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field11 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case -12:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field12, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field12 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_tuple_protocol_test_struct_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestTupleProtocolTestStruct * this_object = T_TEST_TUPLE_PROTOCOL_TEST_STRUCT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TupleProtocolTestStruct", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_field1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "field1", T_I32, -1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->field1, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_field2 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "field2", T_I32, -2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->field2, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_field3 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "field3", T_I32, -3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->field3, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_field4 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "field4", T_I32, -4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->field4, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_field5 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "field5", T_I32, -5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->field5, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_field6 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "field6", T_I32, -6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->field6, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_field7 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "field7", T_I32, -7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->field7, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_field8 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "field8", T_I32, -8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->field8, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_field9 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "field9", T_I32, -9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->field9, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_field10 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "field10", T_I32, -10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->field10, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_field11 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "field11", T_I32, -11, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->field11, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_field12 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "field12", T_I32, -12, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->field12, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_tuple_protocol_test_struct_instance_init (TTestTupleProtocolTestStruct * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->field1 = 0;
  object->__isset_field1 = FALSE;
  object->field2 = 0;
  object->__isset_field2 = FALSE;
  object->field3 = 0;
  object->__isset_field3 = FALSE;
  object->field4 = 0;
  object->__isset_field4 = FALSE;
  object->field5 = 0;
  object->__isset_field5 = FALSE;
  object->field6 = 0;
  object->__isset_field6 = FALSE;
  object->field7 = 0;
  object->__isset_field7 = FALSE;
  object->field8 = 0;
  object->__isset_field8 = FALSE;
  object->field9 = 0;
  object->__isset_field9 = FALSE;
  object->field10 = 0;
  object->__isset_field10 = FALSE;
  object->field11 = 0;
  object->__isset_field11 = FALSE;
  object->field12 = 0;
  object->__isset_field12 = FALSE;
}

static void 
t_test_tuple_protocol_test_struct_finalize (GObject *object)
{
  TTestTupleProtocolTestStruct *tobject = T_TEST_TUPLE_PROTOCOL_TEST_STRUCT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void 
t_test_tuple_protocol_test_struct_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_tuple_protocol_test_struct_finalize;
  cls->read = t_test_tuple_protocol_test_struct_read;
  cls->write = t_test_tuple_protocol_test_struct_write;
}

GType
t_test_tuple_protocol_test_struct_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestTupleProtocolTestStructClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_tuple_protocol_test_struct_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestTupleProtocolTestStruct),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_tuple_protocol_test_struct_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestTupleProtocolTestStructType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */
static TTestEmpty *
t_test_compact_test_constant_empty_struct_field153_constant (void)
{
  static TTestEmpty *constant = NULL;
  if (constant == NULL)
  {
    constant = g_object_new (T_TEST_TYPE_EMPTY, NULL);

  }
  return constant;
}

static GArray *
t_test_compact_test_constant_byte_list154_constant (void)
{
  static GArray * constant = NULL;
  if (constant == NULL)
  {
    constant = g_array_new (0, 1, sizeof (gint8));
    gint8 compact_test_constant_byte_list154155 = -127;
    g_array_append_val(constant, compact_test_constant_byte_list154155);
    gint8 compact_test_constant_byte_list154156 = -1;
    g_array_append_val(constant, compact_test_constant_byte_list154156);
    gint8 compact_test_constant_byte_list154157 = 0;
    g_array_append_val(constant, compact_test_constant_byte_list154157);
    gint8 compact_test_constant_byte_list154158 = 1;
    g_array_append_val(constant, compact_test_constant_byte_list154158);
    gint8 compact_test_constant_byte_list154159 = 127;
    g_array_append_val(constant, compact_test_constant_byte_list154159);

  }
  return constant;
}

static GArray *
t_test_compact_test_constant_i16_list160_constant (void)
{
  static GArray * constant = NULL;
  if (constant == NULL)
  {
    constant = g_array_new (0, 1, sizeof (gint16));
    gint16 compact_test_constant_i16_list160161 = -1;
    g_array_append_val(constant, compact_test_constant_i16_list160161);
    gint16 compact_test_constant_i16_list160162 = 0;
    g_array_append_val(constant, compact_test_constant_i16_list160162);
    gint16 compact_test_constant_i16_list160163 = 1;
    g_array_append_val(constant, compact_test_constant_i16_list160163);
    gint16 compact_test_constant_i16_list160164 = 32767;
    g_array_append_val(constant, compact_test_constant_i16_list160164);

  }
  return constant;
}

static GArray *
t_test_compact_test_constant_i32_list165_constant (void)
{
  static GArray * constant = NULL;
  if (constant == NULL)
  {
    constant = g_array_new (0, 1, sizeof (gint32));
    gint32 compact_test_constant_i32_list165166 = -1;
    g_array_append_val(constant, compact_test_constant_i32_list165166);
    gint32 compact_test_constant_i32_list165167 = 0;
    g_array_append_val(constant, compact_test_constant_i32_list165167);
    gint32 compact_test_constant_i32_list165168 = 255;
    g_array_append_val(constant, compact_test_constant_i32_list165168);
    gint32 compact_test_constant_i32_list165169 = 65535;
    g_array_append_val(constant, compact_test_constant_i32_list165169);
    gint32 compact_test_constant_i32_list165170 = 16777215;
    g_array_append_val(constant, compact_test_constant_i32_list165170);
    gint32 compact_test_constant_i32_list165171 = 2147483647;
    g_array_append_val(constant, compact_test_constant_i32_list165171);

  }
  return constant;
}

static GArray *
t_test_compact_test_constant_i64_list172_constant (void)
{
  static GArray * constant = NULL;
  if (constant == NULL)
  {
    constant = g_array_new (0, 1, sizeof (gint64));
    gint64 compact_test_constant_i64_list172173 = -1;
    g_array_append_val(constant, compact_test_constant_i64_list172173);
    gint64 compact_test_constant_i64_list172174 = 0;
    g_array_append_val(constant, compact_test_constant_i64_list172174);
    gint64 compact_test_constant_i64_list172175 = 255;
    g_array_append_val(constant, compact_test_constant_i64_list172175);
    gint64 compact_test_constant_i64_list172176 = 65535;
    g_array_append_val(constant, compact_test_constant_i64_list172176);
    gint64 compact_test_constant_i64_list172177 = 16777215;
    g_array_append_val(constant, compact_test_constant_i64_list172177);
    gint64 compact_test_constant_i64_list172178 = 4294967295;
    g_array_append_val(constant, compact_test_constant_i64_list172178);
    gint64 compact_test_constant_i64_list172179 = 1099511627775;
    g_array_append_val(constant, compact_test_constant_i64_list172179);
    gint64 compact_test_constant_i64_list172180 = 281474976710655;
    g_array_append_val(constant, compact_test_constant_i64_list172180);
    gint64 compact_test_constant_i64_list172181 = 72057594037927935;
    g_array_append_val(constant, compact_test_constant_i64_list172181);
    gint64 compact_test_constant_i64_list172182 = 9223372036854775807;
    g_array_append_val(constant, compact_test_constant_i64_list172182);

  }
  return constant;
}

static GArray *
t_test_compact_test_constant_double_list183_constant (void)
{
  static GArray * constant = NULL;
  if (constant == NULL)
  {
    constant = g_array_new (0, 1, sizeof (gdouble));
    gdouble compact_test_constant_double_list183184 = 0.1;
    g_array_append_val(constant, compact_test_constant_double_list183184);
    gdouble compact_test_constant_double_list183185 = 0.2;
    g_array_append_val(constant, compact_test_constant_double_list183185);
    gdouble compact_test_constant_double_list183186 = 0.3;
    g_array_append_val(constant, compact_test_constant_double_list183186);

  }
  return constant;
}

static GPtrArray *
t_test_compact_test_constant_string_list187_constant (void)
{
  static GPtrArray * constant = NULL;
  if (constant == NULL)
  {
    constant = g_ptr_array_new_with_free_func (g_free);
    g_ptr_array_add(constant, g_strdup ("first"));
    g_ptr_array_add(constant, g_strdup ("second"));
    g_ptr_array_add(constant, g_strdup ("third"));

  }
  return constant;
}

static GArray *
t_test_compact_test_constant_boolean_list191_constant (void)
{
  static GArray * constant = NULL;
  if (constant == NULL)
  {
    constant = g_array_new (0, 1, sizeof (gboolean));
    gboolean compact_test_constant_boolean_list191192 = 1;
    g_array_append_val(constant, compact_test_constant_boolean_list191192);
    gboolean compact_test_constant_boolean_list191193 = 1;
    g_array_append_val(constant, compact_test_constant_boolean_list191193);
    gboolean compact_test_constant_boolean_list191194 = 1;
    g_array_append_val(constant, compact_test_constant_boolean_list191194);
    gboolean compact_test_constant_boolean_list191195 = 0;
    g_array_append_val(constant, compact_test_constant_boolean_list191195);
    gboolean compact_test_constant_boolean_list191196 = 0;
    g_array_append_val(constant, compact_test_constant_boolean_list191196);
    gboolean compact_test_constant_boolean_list191197 = 0;
    g_array_append_val(constant, compact_test_constant_boolean_list191197);

  }
  return constant;
}

static TTestEmpty *
t_test_compact_test_constant_struct_list198199_constant (void)
{
  static TTestEmpty *constant = NULL;
  if (constant == NULL)
  {
    constant = g_object_new (T_TEST_TYPE_EMPTY, NULL);

  }
  return constant;
}

static TTestEmpty *
t_test_compact_test_constant_struct_list198200_constant (void)
{
  static TTestEmpty *constant = NULL;
  if (constant == NULL)
  {
    constant = g_object_new (T_TEST_TYPE_EMPTY, NULL);

  }
  return constant;
}

static GPtrArray *
t_test_compact_test_constant_struct_list198_constant (void)
{
  static GPtrArray * constant = NULL;
  if (constant == NULL)
  {
    constant = g_ptr_array_new_with_free_func (g_object_unref);
    g_ptr_array_add(constant, (t_test_compact_test_constant_struct_list198199_constant()));
    g_ptr_array_add(constant, (t_test_compact_test_constant_struct_list198200_constant()));

  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_byte_set201_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    constant = g_hash_table_new (NULL, NULL);
    gint8 compact_test_constant_byte_set201202 = -127;
    g_hash_table_insert (constant, &compact_test_constant_byte_set201202, &compact_test_constant_byte_set201202);
    gint8 compact_test_constant_byte_set201203 = -1;
    g_hash_table_insert (constant, &compact_test_constant_byte_set201203, &compact_test_constant_byte_set201203);
    gint8 compact_test_constant_byte_set201204 = 0;
    g_hash_table_insert (constant, &compact_test_constant_byte_set201204, &compact_test_constant_byte_set201204);
    gint8 compact_test_constant_byte_set201205 = 1;
    g_hash_table_insert (constant, &compact_test_constant_byte_set201205, &compact_test_constant_byte_set201205);
    gint8 compact_test_constant_byte_set201206 = 127;
    g_hash_table_insert (constant, &compact_test_constant_byte_set201206, &compact_test_constant_byte_set201206);

  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_i16_set207_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    constant = g_hash_table_new (NULL, NULL);
    gint16 compact_test_constant_i16_set207208 = -1;
    g_hash_table_insert (constant, &compact_test_constant_i16_set207208, &compact_test_constant_i16_set207208);
    gint16 compact_test_constant_i16_set207209 = 0;
    g_hash_table_insert (constant, &compact_test_constant_i16_set207209, &compact_test_constant_i16_set207209);
    gint16 compact_test_constant_i16_set207210 = 1;
    g_hash_table_insert (constant, &compact_test_constant_i16_set207210, &compact_test_constant_i16_set207210);
    gint16 compact_test_constant_i16_set207211 = 32767;
    g_hash_table_insert (constant, &compact_test_constant_i16_set207211, &compact_test_constant_i16_set207211);

  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_i32_set212_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    constant = g_hash_table_new (NULL, NULL);
    gint32 compact_test_constant_i32_set212213 = 1;
    g_hash_table_insert (constant, &compact_test_constant_i32_set212213, &compact_test_constant_i32_set212213);
    gint32 compact_test_constant_i32_set212214 = 2;
    g_hash_table_insert (constant, &compact_test_constant_i32_set212214, &compact_test_constant_i32_set212214);
    gint32 compact_test_constant_i32_set212215 = 3;
    g_hash_table_insert (constant, &compact_test_constant_i32_set212215, &compact_test_constant_i32_set212215);

  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_i64_set216_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    constant = g_hash_table_new (NULL, NULL);
    gint64 compact_test_constant_i64_set216217 = -1;
    g_hash_table_insert (constant, &compact_test_constant_i64_set216217, &compact_test_constant_i64_set216217);
    gint64 compact_test_constant_i64_set216218 = 0;
    g_hash_table_insert (constant, &compact_test_constant_i64_set216218, &compact_test_constant_i64_set216218);
    gint64 compact_test_constant_i64_set216219 = 255;
    g_hash_table_insert (constant, &compact_test_constant_i64_set216219, &compact_test_constant_i64_set216219);
    gint64 compact_test_constant_i64_set216220 = 65535;
    g_hash_table_insert (constant, &compact_test_constant_i64_set216220, &compact_test_constant_i64_set216220);
    gint64 compact_test_constant_i64_set216221 = 16777215;
    g_hash_table_insert (constant, &compact_test_constant_i64_set216221, &compact_test_constant_i64_set216221);
    gint64 compact_test_constant_i64_set216222 = 4294967295;
    g_hash_table_insert (constant, &compact_test_constant_i64_set216222, &compact_test_constant_i64_set216222);
    gint64 compact_test_constant_i64_set216223 = 1099511627775;
    g_hash_table_insert (constant, &compact_test_constant_i64_set216223, &compact_test_constant_i64_set216223);
    gint64 compact_test_constant_i64_set216224 = 281474976710655;
    g_hash_table_insert (constant, &compact_test_constant_i64_set216224, &compact_test_constant_i64_set216224);
    gint64 compact_test_constant_i64_set216225 = 72057594037927935;
    g_hash_table_insert (constant, &compact_test_constant_i64_set216225, &compact_test_constant_i64_set216225);
    gint64 compact_test_constant_i64_set216226 = 9223372036854775807;
    g_hash_table_insert (constant, &compact_test_constant_i64_set216226, &compact_test_constant_i64_set216226);

  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_double_set227_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    constant = g_hash_table_new (NULL, NULL);
    gdouble compact_test_constant_double_set227228 = 0.1;
    g_hash_table_insert (constant, &compact_test_constant_double_set227228, &compact_test_constant_double_set227228);
    gdouble compact_test_constant_double_set227229 = 0.2;
    g_hash_table_insert (constant, &compact_test_constant_double_set227229, &compact_test_constant_double_set227229);
    gdouble compact_test_constant_double_set227230 = 0.3;
    g_hash_table_insert (constant, &compact_test_constant_double_set227230, &compact_test_constant_double_set227230);

  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_string_set231_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    constant = g_hash_table_new (NULL, NULL);
    gchar * compact_test_constant_string_set231232 = g_strdup ("first");
    g_hash_table_insert (constant, &compact_test_constant_string_set231232, &compact_test_constant_string_set231232);
    gchar * compact_test_constant_string_set231233 = g_strdup ("second");
    g_hash_table_insert (constant, &compact_test_constant_string_set231233, &compact_test_constant_string_set231233);
    gchar * compact_test_constant_string_set231234 = g_strdup ("third");
    g_hash_table_insert (constant, &compact_test_constant_string_set231234, &compact_test_constant_string_set231234);

  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_boolean_set235_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    constant = g_hash_table_new (NULL, NULL);
    gboolean compact_test_constant_boolean_set235236 = 1;
    g_hash_table_insert (constant, &compact_test_constant_boolean_set235236, &compact_test_constant_boolean_set235236);
    gboolean compact_test_constant_boolean_set235237 = 0;
    g_hash_table_insert (constant, &compact_test_constant_boolean_set235237, &compact_test_constant_boolean_set235237);

  }
  return constant;
}

static TTestEmpty *
t_test_compact_test_constant_struct_set238239_constant (void)
{
  static TTestEmpty *constant = NULL;
  if (constant == NULL)
  {
    constant = g_object_new (T_TEST_TYPE_EMPTY, NULL);

  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_struct_set238_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    constant = g_hash_table_new (NULL, NULL);
    TTestEmpty * compact_test_constant_struct_set238239 = (t_test_compact_test_constant_struct_set238239_constant());
    g_hash_table_insert (constant, &compact_test_constant_struct_set238239, &compact_test_constant_struct_set238239);

  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_byte_byte_map240_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    constant = g_hash_table_new (NULL, NULL);

  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_i16_byte_map241_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    constant = g_hash_table_new (NULL, NULL);

  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_i32_byte_map242_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    constant = g_hash_table_new (NULL, NULL);

  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_i64_byte_map243_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    constant = g_hash_table_new (NULL, NULL);

  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_double_byte_map244_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    constant = g_hash_table_new (NULL, NULL);

  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_string_byte_map245_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    constant = g_hash_table_new (NULL, NULL);

  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_boolean_byte_map246_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    constant = g_hash_table_new (NULL, NULL);

  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_byte_i16_map247_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    constant = g_hash_table_new (NULL, NULL);

  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_byte_i32_map248_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    constant = g_hash_table_new (NULL, NULL);

  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_byte_i64_map249_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    constant = g_hash_table_new (NULL, NULL);

  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_byte_double_map250_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    constant = g_hash_table_new (NULL, NULL);

  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_byte_string_map251_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    constant = g_hash_table_new (NULL, NULL);

  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_byte_boolean_map252_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    constant = g_hash_table_new (NULL, NULL);

  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_list_byte_map253_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    constant = g_hash_table_new (NULL, NULL);

  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_set_byte_map254_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    constant = g_hash_table_new (NULL, NULL);

  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_map_byte_map255_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    constant = g_hash_table_new (NULL, NULL);

  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_byte_map_map256_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    constant = g_hash_table_new (NULL, NULL);

  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_byte_set_map257_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    constant = g_hash_table_new (NULL, NULL);

  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_byte_list_map258_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    constant = g_hash_table_new (NULL, NULL);

  }
  return constant;
}

static TTestCompactProtoTestStruct *
t_test_compact_test_constant (void)
{
  static TTestCompactProtoTestStruct *constant = NULL;
  if (constant == NULL)
  {
    constant = g_object_new (T_TEST_TYPE_COMPACT_PROTO_TEST_STRUCT, NULL);
    constant->a_byte = 127;
    constant->__isset_a_byte = TRUE;
    constant->a_i16 = 32000;
    constant->__isset_a_i16 = TRUE;
    constant->a_i32 = 1000000000;
    constant->__isset_a_i32 = TRUE;
    constant->a_i64 = 1099511627775;
    constant->__isset_a_i64 = TRUE;
    constant->a_double = 5.6789;
    constant->__isset_a_double = TRUE;
    constant->a_string = g_strdup ("my string");
    constant->__isset_a_string = TRUE;
    constant->true_field = 1;
    constant->__isset_true_field = TRUE;
    constant->false_field = 0;
    constant->__isset_false_field = TRUE;
    constant->empty_struct_field = (t_test_compact_test_constant_empty_struct_field153_constant());
    constant->__isset_empty_struct_field = TRUE;
    constant->byte_list = (t_test_compact_test_constant_byte_list154_constant());
    constant->__isset_byte_list = TRUE;
    constant->i16_list = (t_test_compact_test_constant_i16_list160_constant());
    constant->__isset_i16_list = TRUE;
    constant->i32_list = (t_test_compact_test_constant_i32_list165_constant());
    constant->__isset_i32_list = TRUE;
    constant->i64_list = (t_test_compact_test_constant_i64_list172_constant());
    constant->__isset_i64_list = TRUE;
    constant->double_list = (t_test_compact_test_constant_double_list183_constant());
    constant->__isset_double_list = TRUE;
    constant->string_list = (t_test_compact_test_constant_string_list187_constant());
    constant->__isset_string_list = TRUE;
    constant->boolean_list = (t_test_compact_test_constant_boolean_list191_constant());
    constant->__isset_boolean_list = TRUE;
    constant->struct_list = (t_test_compact_test_constant_struct_list198_constant());
    constant->__isset_struct_list = TRUE;
    constant->byte_set = (t_test_compact_test_constant_byte_set201_constant());
    constant->__isset_byte_set = TRUE;
    constant->i16_set = (t_test_compact_test_constant_i16_set207_constant());
    constant->__isset_i16_set = TRUE;
    constant->i32_set = (t_test_compact_test_constant_i32_set212_constant());
    constant->__isset_i32_set = TRUE;
    constant->i64_set = (t_test_compact_test_constant_i64_set216_constant());
    constant->__isset_i64_set = TRUE;
    constant->double_set = (t_test_compact_test_constant_double_set227_constant());
    constant->__isset_double_set = TRUE;
    constant->string_set = (t_test_compact_test_constant_string_set231_constant());
    constant->__isset_string_set = TRUE;
    constant->boolean_set = (t_test_compact_test_constant_boolean_set235_constant());
    constant->__isset_boolean_set = TRUE;
    constant->struct_set = (t_test_compact_test_constant_struct_set238_constant());
    constant->__isset_struct_set = TRUE;
    constant->byte_byte_map = (t_test_compact_test_constant_byte_byte_map240_constant());
    constant->__isset_byte_byte_map = TRUE;
    constant->i16_byte_map = (t_test_compact_test_constant_i16_byte_map241_constant());
    constant->__isset_i16_byte_map = TRUE;
    constant->i32_byte_map = (t_test_compact_test_constant_i32_byte_map242_constant());
    constant->__isset_i32_byte_map = TRUE;
    constant->i64_byte_map = (t_test_compact_test_constant_i64_byte_map243_constant());
    constant->__isset_i64_byte_map = TRUE;
    constant->double_byte_map = (t_test_compact_test_constant_double_byte_map244_constant());
    constant->__isset_double_byte_map = TRUE;
    constant->string_byte_map = (t_test_compact_test_constant_string_byte_map245_constant());
    constant->__isset_string_byte_map = TRUE;
    constant->boolean_byte_map = (t_test_compact_test_constant_boolean_byte_map246_constant());
    constant->__isset_boolean_byte_map = TRUE;
    constant->byte_i16_map = (t_test_compact_test_constant_byte_i16_map247_constant());
    constant->__isset_byte_i16_map = TRUE;
    constant->byte_i32_map = (t_test_compact_test_constant_byte_i32_map248_constant());
    constant->__isset_byte_i32_map = TRUE;
    constant->byte_i64_map = (t_test_compact_test_constant_byte_i64_map249_constant());
    constant->__isset_byte_i64_map = TRUE;
    constant->byte_double_map = (t_test_compact_test_constant_byte_double_map250_constant());
    constant->__isset_byte_double_map = TRUE;
    constant->byte_string_map = (t_test_compact_test_constant_byte_string_map251_constant());
    constant->__isset_byte_string_map = TRUE;
    constant->byte_boolean_map = (t_test_compact_test_constant_byte_boolean_map252_constant());
    constant->__isset_byte_boolean_map = TRUE;
    constant->list_byte_map = (t_test_compact_test_constant_list_byte_map253_constant());
    constant->__isset_list_byte_map = TRUE;
    constant->set_byte_map = (t_test_compact_test_constant_set_byte_map254_constant());
    constant->__isset_set_byte_map = TRUE;
    constant->map_byte_map = (t_test_compact_test_constant_map_byte_map255_constant());
    constant->__isset_map_byte_map = TRUE;
    constant->byte_map_map = (t_test_compact_test_constant_byte_map_map256_constant());
    constant->__isset_byte_map_map = TRUE;
    constant->byte_set_map = (t_test_compact_test_constant_byte_set_map257_constant());
    constant->__isset_byte_set_map = TRUE;
    constant->byte_list_map = (t_test_compact_test_constant_byte_list_map258_constant());
    constant->__isset_byte_list_map = TRUE;

  }
  return constant;
}

static GHashTable *
t_test_my_enum_map_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    constant = g_hash_table_new (NULL, NULL);

  }
  return constant;
}

static GHashTable *
t_test_extra_crazy_map_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    constant = g_hash_table_new (NULL, NULL);

  }
  return constant;
}


