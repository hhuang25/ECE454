/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include "t_test_thrift_test_types.h"
#include <thrift/c_glib/thrift.h>

/* reads a bonk object */
static gint32
t_test_bonk_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestBonk * this_object = T_TEST_BONK(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->message != NULL)
          {
            g_free(this_object->message);
            this_object->message = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->message, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_message = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->type, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_bonk_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestBonk * this_object = T_TEST_BONK(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Bonk", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->message, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->type, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_bonk_instance_init (TTestBonk * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->message = NULL;
  object->__isset_message = FALSE;
  object->type = 0;
  object->__isset_type = FALSE;
}

static void 
t_test_bonk_finalize (GObject *object)
{
  TTestBonk *tobject = T_TEST_BONK (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->message != NULL)
  {
    g_free (tobject->message);
    tobject->message = NULL;
  }
}

static void 
t_test_bonk_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_bonk_finalize;
  cls->read = t_test_bonk_read;
  cls->write = t_test_bonk_write;
}

GType
t_test_bonk_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestBonkClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_bonk_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestBonk),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_bonk_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestBonkType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a bools object */
static gint32
t_test_bools_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestBools * this_object = T_TEST_BOOLS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->im_true, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_im_true = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->im_false, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_im_false = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_bools_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestBools * this_object = T_TEST_BOOLS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Bools", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "im_true", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->im_true, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "im_false", T_BOOL, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->im_false, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_bools_instance_init (TTestBools * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->im_true = 0;
  object->__isset_im_true = FALSE;
  object->im_false = 0;
  object->__isset_im_false = FALSE;
}

static void 
t_test_bools_finalize (GObject *object)
{
  TTestBools *tobject = T_TEST_BOOLS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void 
t_test_bools_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_bools_finalize;
  cls->read = t_test_bools_read;
  cls->write = t_test_bools_write;
}

GType
t_test_bools_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestBoolsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_bools_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestBools),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_bools_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestBoolsType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a xtruct object */
static gint32
t_test_xtruct_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestXtruct * this_object = T_TEST_XTRUCT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->string_thing != NULL)
          {
            g_free(this_object->string_thing);
            this_object->string_thing = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->string_thing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_string_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->byte_thing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_byte_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->i32_thing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_i32_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->i64_thing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_i64_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_xtruct_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestXtruct * this_object = T_TEST_XTRUCT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Xtruct", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "string_thing", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->string_thing, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_thing", T_BYTE, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->byte_thing, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i32_thing", T_I32, 9, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->i32_thing, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i64_thing", T_I64, 11, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->i64_thing, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_xtruct_instance_init (TTestXtruct * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->string_thing = NULL;
  object->__isset_string_thing = FALSE;
  object->byte_thing = 0;
  object->__isset_byte_thing = FALSE;
  object->i32_thing = 0;
  object->__isset_i32_thing = FALSE;
  object->i64_thing = 0;
  object->__isset_i64_thing = FALSE;
}

static void 
t_test_xtruct_finalize (GObject *object)
{
  TTestXtruct *tobject = T_TEST_XTRUCT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->string_thing != NULL)
  {
    g_free (tobject->string_thing);
    tobject->string_thing = NULL;
  }
}

static void 
t_test_xtruct_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_xtruct_finalize;
  cls->read = t_test_xtruct_read;
  cls->write = t_test_xtruct_write;
}

GType
t_test_xtruct_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestXtructClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_xtruct_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestXtruct),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_xtruct_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestXtructType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a xtruct2 object */
static gint32
t_test_xtruct2_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestXtruct2 * this_object = T_TEST_XTRUCT2(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->byte_thing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_byte_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->struct_thing), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_struct_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->i32_thing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_i32_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_xtruct2_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestXtruct2 * this_object = T_TEST_XTRUCT2(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Xtruct2", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_thing", T_BYTE, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->byte_thing, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "struct_thing", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->struct_thing), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i32_thing", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->i32_thing, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_xtruct2_instance_init (TTestXtruct2 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->byte_thing = 0;
  object->__isset_byte_thing = FALSE;
  object->struct_thing = g_object_new (T_TEST_TYPE_XTRUCT, NULL);
  object->__isset_struct_thing = FALSE;
  object->i32_thing = 0;
  object->__isset_i32_thing = FALSE;
}

static void 
t_test_xtruct2_finalize (GObject *object)
{
  TTestXtruct2 *tobject = T_TEST_XTRUCT2 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->struct_thing != NULL)
  {
    g_object_unref(tobject->struct_thing);
    tobject->struct_thing = NULL;
  }
}

static void 
t_test_xtruct2_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_xtruct2_finalize;
  cls->read = t_test_xtruct2_read;
  cls->write = t_test_xtruct2_write;
}

GType
t_test_xtruct2_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestXtruct2Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_xtruct2_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestXtruct2),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_xtruct2_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestXtruct2Type",
                                   &type_info, 0);
  }

  return type;
}

/* reads a xtruct3 object */
static gint32
t_test_xtruct3_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestXtruct3 * this_object = T_TEST_XTRUCT3(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->string_thing != NULL)
          {
            g_free(this_object->string_thing);
            this_object->string_thing = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->string_thing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_string_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->changed, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_changed = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->i32_thing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_i32_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->i64_thing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_i64_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_xtruct3_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestXtruct3 * this_object = T_TEST_XTRUCT3(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Xtruct3", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "string_thing", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->string_thing, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "changed", T_I32, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->changed, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i32_thing", T_I32, 9, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->i32_thing, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i64_thing", T_I64, 11, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->i64_thing, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_xtruct3_instance_init (TTestXtruct3 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->string_thing = NULL;
  object->__isset_string_thing = FALSE;
  object->changed = 0;
  object->__isset_changed = FALSE;
  object->i32_thing = 0;
  object->__isset_i32_thing = FALSE;
  object->i64_thing = 0;
  object->__isset_i64_thing = FALSE;
}

static void 
t_test_xtruct3_finalize (GObject *object)
{
  TTestXtruct3 *tobject = T_TEST_XTRUCT3 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->string_thing != NULL)
  {
    g_free (tobject->string_thing);
    tobject->string_thing = NULL;
  }
}

static void 
t_test_xtruct3_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_xtruct3_finalize;
  cls->read = t_test_xtruct3_read;
  cls->write = t_test_xtruct3_write;
}

GType
t_test_xtruct3_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestXtruct3Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_xtruct3_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestXtruct3),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_xtruct3_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestXtruct3Type",
                                   &type_info, 0);
  }

  return type;
}

/* reads a insanity object */
static gint32
t_test_insanity_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestInsanity * this_object = T_TEST_INSANITY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              TTestNumberz key0;
              TTestUserId val1 = NULL;
              gint32 ecast2;
              if ((ret = thrift_protocol_read_i32 (protocol, &ecast2, error)) < 0)
                return -1;
              xfer += ret;
              key0 = (TTestNumberz)ecast2;
              if ((ret = thrift_protocol_read_i64 (protocol, &val1, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->userMap, (gpointer) key0, (gpointer) val1);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_userMap = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              TTestXtruct * _elem3 = NULL;
              if ( _elem3 != NULL)
              {
                g_object_unref (_elem3);
              }
              _elem3 = g_object_new (T_TEST_TYPE_XTRUCT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem3), protocol, error)) < 0)
              {
                g_object_unref (_elem3);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->xtructs, _elem3);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_xtructs = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_insanity_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestInsanity * this_object = T_TEST_INSANITY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Insanity", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "userMap", T_MAP, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_I64, (gint32) g_hash_table_size ((GHashTable *) this_object->userMap), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    TTestNumberz key;
    TTestUserId value;
    g_hash_table_foreach ((GHashTable *) this_object->userMap, thrift_hash_table_get_keys, &key_list);
    TTestNumberz keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (TTestNumberz) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (TTestUserId) g_hash_table_lookup (((GHashTable *) this_object->userMap), (gpointer) key);

      if ((ret = thrift_protocol_write_i32 (protocol, (gint32)  key, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_i64 (protocol,  value, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "xtructs", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->xtructs->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i4;
    for (i4=0; i4<this_object->xtructs->len; i4++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->xtructs, i4))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_insanity_instance_init (TTestInsanity * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->userMap = g_hash_table_new_full (g_direct_hash, NULL, NULL, NULL);
  object->__isset_userMap = FALSE;
  object->xtructs = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_xtructs = FALSE;
}

static void 
t_test_insanity_finalize (GObject *object)
{
  TTestInsanity *tobject = T_TEST_INSANITY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->userMap != NULL)
  {
    g_hash_table_destroy (tobject->userMap);
    tobject->userMap = NULL;
  }
  if (tobject->xtructs != NULL)
  {
    g_ptr_array_free (tobject->xtructs, TRUE);
    tobject->xtructs = NULL;
  }
}

static void 
t_test_insanity_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_insanity_finalize;
  cls->read = t_test_insanity_read;
  cls->write = t_test_insanity_write;
}

GType
t_test_insanity_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestInsanityClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_insanity_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestInsanity),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_insanity_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestInsanityType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a crazy_nesting object */
static gint32
t_test_crazy_nesting_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestCrazyNesting * this_object = T_TEST_CRAZY_NESTING(object);
  gboolean isset_list_field = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->string_field != NULL)
          {
            g_free(this_object->string_field);
            this_object->string_field = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->string_field, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_string_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            guint32 i;
            for (i = 0; i < size; ++i)
            {
              TTestInsanity * _elem5 = NULL;
              if ( _elem5 != NULL)
              {
                g_object_unref (_elem5);
              }
              _elem5 = g_object_new (T_TEST_TYPE_INSANITY, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem5), protocol, error)) < 0)
              {
                g_object_unref (_elem5);
                return -1;
              }
              xfer += ret;
              g_hash_table_insert ((GHashTable *) this_object->set_field, (gpointer) _elem5, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_set_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              GHashTable * _elem6 = g_hash_table_new (NULL, NULL);
              {
                guint32 size;
                ThriftType key_type;
                ThriftType value_type;

                /* read the map begin marker */
                if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through each of the map's fields */
                guint32 i;
                for (i = 0; i < size; i++)
                {
                  GHashTable * key7 = NULL;
                  GHashTable * val8 = g_hash_table_new (NULL, NULL);
                  {
                    guint32 size;
                    ThriftType element_type;
                    if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
                      return -1;
                    xfer += ret;

                    /* iterate through the set elements */
                    guint32 i;
                    for (i = 0; i < size; ++i)
                    {
                      gint32* _elem9 = g_new (gint32, 1);
                      if ((ret = thrift_protocol_read_i32 (protocol, &*_elem9, error)) < 0)
                        return -1;
                      xfer += ret;
                      g_hash_table_insert ((GHashTable *) key7, (gpointer) _elem9, (gpointer) 1);
                    }
                    if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
                      return -1;
                    xfer += ret;

                  }
                  {
                    guint32 size;
                    ThriftType key_type;
                    ThriftType value_type;

                    /* read the map begin marker */
                    if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                      return -1;
                    xfer += ret;

                    /* iterate through each of the map's fields */
                    guint32 i;
                    for (i = 0; i < size; i++)
                    {
                      gint32* key10 = g_new (gint32, 1);
                      GHashTable * val11 = NULL;
                      if ((ret = thrift_protocol_read_i32 (protocol, &*key10, error)) < 0)
                        return -1;
                      xfer += ret;
                      {
                        guint32 size;
                        ThriftType element_type;
                        if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
                          return -1;
                        xfer += ret;

                        /* iterate through the set elements */
                        guint32 i;
                        for (i = 0; i < size; ++i)
                        {
                          GPtrArray * _elem12 = NULL;
                          {
                            guint32 size;
                            ThriftType element_type;
                            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
                              return -1;
                            xfer += ret;

                            /* iterate through list elements */
                            guint32 i;
                            for (i = 0; i < size; i++)
                            {
                              GHashTable * _elem13 = g_hash_table_new (NULL, NULL);
                              {
                                guint32 size;
                                ThriftType key_type;
                                ThriftType value_type;

                                /* read the map begin marker */
                                if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                                  return -1;
                                xfer += ret;

                                /* iterate through each of the map's fields */
                                guint32 i;
                                for (i = 0; i < size; i++)
                                {
                                  TTestInsanity * key14 = NULL;
                                  gchar * val15 = NULL;
                                  if ( key14 != NULL)
                                  {
                                    g_object_unref (key14);
                                  }
                                  key14 = g_object_new (T_TEST_TYPE_INSANITY, NULL);
                                  if ((ret = thrift_struct_read (THRIFT_STRUCT (key14), protocol, error)) < 0)
                                  {
                                    g_object_unref (key14);
                                    return -1;
                                  }
                                  xfer += ret;
                                  if (val15 != NULL)
                                  {
                                    g_free(val15);
                                    val15 = NULL;
                                  }

                                  if ((ret = thrift_protocol_read_string (protocol, &val15, error)) < 0)
                                    return -1;
                                  xfer += ret;
                                  g_hash_table_insert ((GHashTable *)_elem13, (gpointer) key14, (gpointer) val15);
                                }

                                /* read the map end marker */
                                if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                                  return -1;
                                xfer += ret;
                              }
                              g_ptr_array_add (_elem12, _elem13);
                            }
                            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                              return -1;
                            xfer += ret;

                          }
                          g_hash_table_insert ((GHashTable *) val11, (gpointer) _elem12, (gpointer) 1);
                        }
                        if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
                          return -1;
                        xfer += ret;

                      }
                      g_hash_table_insert ((GHashTable *)val8, (gpointer) key10, (gpointer) val11);
                    }

                    /* read the map end marker */
                    if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                      return -1;
                    xfer += ret;
                  }
                  g_hash_table_insert ((GHashTable *)_elem6, (gpointer) key7, (gpointer) val8);
                }

                /* read the map end marker */
                if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              g_ptr_array_add (this_object->list_field, _elem6);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          isset_list_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->binary_field != NULL)
          {
            g_free(this_object->binary_field);
            this_object->binary_field = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->binary_field = g_byte_array_new();
          g_byte_array_append (this_object->binary_field, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_binary_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_list_field)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_test_crazy_nesting_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestCrazyNesting * this_object = T_TEST_CRAZY_NESTING(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CrazyNesting", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "string_field", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->string_field, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_set_field == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "set_field", T_SET, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      if ((ret = thrift_protocol_write_set_begin (protocol, T_STRUCT, (gint32) g_hash_table_size ((GHashTable *) this_object->set_field), error)) < 0)
        return -1;
      xfer += ret;
      GList *key_list = NULL, *iter = NULL;
      TTestInsanity * elem;
      gpointer value;
      THRIFT_UNUSED_VAR (value);

      g_hash_table_foreach ((GHashTable *) this_object->set_field, thrift_hash_table_get_keys, &key_list);
      TTestInsanity * keys[g_list_length (key_list)];
      int i=0, key_count = g_list_length (key_list);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
      {
        keys[i++] = (TTestInsanity *) iter->data;
      }
      g_list_free (key_list);

      for (i=0; i<key_count; ++i)
      {
        elem = keys[i];
        value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->set_field), (gpointer) elem);

        if ((ret = thrift_struct_write (THRIFT_STRUCT (elem), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "list_field", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_MAP, (gint32) this_object->list_field->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i16;
    for (i16=0; i16<this_object->list_field->len; i16++)
    {
      {
        if ((ret = thrift_protocol_write_map_begin (protocol, T_SET, T_MAP, (gint32) g_hash_table_size ((GHashTable *) ((GHashTable*)g_ptr_array_index ((GPtrArray *) this_object->list_field, i16))), error)) < 0)
          return -1;
        xfer += ret;

        GList *key_list = NULL, *iter = NULL;
        GHashTable * key;
        GHashTable * value;
        g_hash_table_foreach ((GHashTable *) ((GHashTable*)g_ptr_array_index ((GPtrArray *) this_object->list_field, i16)), thrift_hash_table_get_keys, &key_list);
        GHashTable * keys[g_list_length (key_list)];
        int i=0, key_count = g_list_length (key_list);
        for (iter = g_list_first (key_list); iter; iter = iter->next)
        {
          keys[i++] = (GHashTable *) iter->data;
        }
        g_list_free (key_list);

        for (i = 0; i < key_count; ++i)
        {
          key = keys[i];
          value = (GHashTable *) g_hash_table_lookup (((GHashTable *) ((GHashTable*)g_ptr_array_index ((GPtrArray *) this_object->list_field, i16))), (gpointer) key);

          {
            if ((ret = thrift_protocol_write_set_begin (protocol, T_I32, (gint32) g_hash_table_size ((GHashTable *)  key), error)) < 0)
              return -1;
            xfer += ret;
            GList *key_list = NULL, *iter = NULL;
            gint32* elem;
            gpointer value;
            THRIFT_UNUSED_VAR (value);

            g_hash_table_foreach ((GHashTable *)  key, thrift_hash_table_get_keys, &key_list);
            gint32* keys[g_list_length (key_list)];
            int i=0, key_count = g_list_length (key_list);
            for (iter = g_list_first (key_list); iter; iter = iter->next)
            {
              keys[i++] = (gint32*) iter->data;
            }
            g_list_free (key_list);

            for (i=0; i<key_count; ++i)
            {
              elem = keys[i];
              value = (gpointer) g_hash_table_lookup (((GHashTable *)  key), (gpointer) elem);

              if ((ret = thrift_protocol_write_i32 (protocol, *elem, error)) < 0)
                return -1;
            }
            if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          {
            if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_SET, (gint32) g_hash_table_size ((GHashTable *)  value), error)) < 0)
              return -1;
            xfer += ret;

            GList *key_list = NULL, *iter = NULL;
            gint32* key;
            GHashTable * value;
            g_hash_table_foreach ((GHashTable *)  value, thrift_hash_table_get_keys, &key_list);
            gint32* keys[g_list_length (key_list)];
            int i=0, key_count = g_list_length (key_list);
            for (iter = g_list_first (key_list); iter; iter = iter->next)
            {
              keys[i++] = (gint32*) iter->data;
            }
            g_list_free (key_list);

            for (i = 0; i < key_count; ++i)
            {
              key = keys[i];
              value = (GHashTable *) g_hash_table_lookup (((GHashTable *)  value), (gpointer) key);

              if ((ret = thrift_protocol_write_i32 (protocol, * key, error)) < 0)
                return -1;
              {
                if ((ret = thrift_protocol_write_set_begin (protocol, T_LIST, (gint32) g_hash_table_size ((GHashTable *)  value), error)) < 0)
                  return -1;
                xfer += ret;
                GList *key_list = NULL, *iter = NULL;
                GPtrArray * elem;
                gpointer value;
                THRIFT_UNUSED_VAR (value);

                g_hash_table_foreach ((GHashTable *)  value, thrift_hash_table_get_keys, &key_list);
                GPtrArray * keys[g_list_length (key_list)];
                int i=0, key_count = g_list_length (key_list);
                for (iter = g_list_first (key_list); iter; iter = iter->next)
                {
                  keys[i++] = (GPtrArray *) iter->data;
                }
                g_list_free (key_list);

                for (i=0; i<key_count; ++i)
                {
                  elem = keys[i];
                  value = (gpointer) g_hash_table_lookup (((GHashTable *)  value), (gpointer) elem);

                  {
                    if ((ret = thrift_protocol_write_list_begin (protocol, T_MAP, (gint32) elem->len, error)) < 0)
                      return -1;
                    xfer += ret;
                    guint i17;
                    for (i17=0; i17<elem->len; i17++)
                    {
                      {
                        if ((ret = thrift_protocol_write_map_begin (protocol, T_STRUCT, T_STRING, (gint32) g_hash_table_size ((GHashTable *) ((GHashTable*)g_ptr_array_index ((GPtrArray *) elem, i17))), error)) < 0)
                          return -1;
                        xfer += ret;

                        GList *key_list = NULL, *iter = NULL;
                        TTestInsanity * key;
                        gchar * value;
                        g_hash_table_foreach ((GHashTable *) ((GHashTable*)g_ptr_array_index ((GPtrArray *) elem, i17)), thrift_hash_table_get_keys, &key_list);
                        TTestInsanity * keys[g_list_length (key_list)];
                        int i=0, key_count = g_list_length (key_list);
                        for (iter = g_list_first (key_list); iter; iter = iter->next)
                        {
                          keys[i++] = (TTestInsanity *) iter->data;
                        }
                        g_list_free (key_list);

                        for (i = 0; i < key_count; ++i)
                        {
                          key = keys[i];
                          value = (gchar *) g_hash_table_lookup (((GHashTable *) ((GHashTable*)g_ptr_array_index ((GPtrArray *) elem, i17))), (gpointer) key);

                          if ((ret = thrift_struct_write (THRIFT_STRUCT ( key), protocol, error)) < 0)
                            return -1;
                          xfer += ret;

                          if ((ret = thrift_protocol_write_string (protocol,  value, error)) < 0)
                            return -1;
                        }
                        if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
                          return -1;
                        xfer += ret;
                      }
                    }
                    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
                      return -1;
                    xfer += ret;
                  }
                }
                if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
            }
            if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
        }
        if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "binary_field", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->binary_field)->data, ((GByteArray *) this_object->binary_field)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_crazy_nesting_instance_init (TTestCrazyNesting * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->string_field = NULL;
  object->__isset_string_field = FALSE;
  object->set_field = g_hash_table_new_full (g_direct_hash, g_direct_equal, g_object_unref, NULL);
  object->__isset_set_field = FALSE;
  object->list_field = g_ptr_array_new_with_free_func ((GDestroyNotify) g_hash_table_destroy);
  object->binary_field = NULL;
  object->__isset_binary_field = FALSE;
}

static void 
t_test_crazy_nesting_finalize (GObject *object)
{
  TTestCrazyNesting *tobject = T_TEST_CRAZY_NESTING (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->string_field != NULL)
  {
    g_free (tobject->string_field);
    tobject->string_field = NULL;
  }
  if (tobject->set_field != NULL)
  {
    g_hash_table_destroy (tobject->set_field);
    tobject->set_field = NULL;
  }
  if (tobject->list_field != NULL)
  {
    g_ptr_array_free (tobject->list_field, TRUE);
    tobject->list_field = NULL;
  }
  if (tobject->binary_field != NULL)
  {
    g_free (tobject->binary_field);
    tobject->binary_field = NULL;
  }
}

static void 
t_test_crazy_nesting_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_crazy_nesting_finalize;
  cls->read = t_test_crazy_nesting_read;
  cls->write = t_test_crazy_nesting_write;
}

GType
t_test_crazy_nesting_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestCrazyNestingClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_crazy_nesting_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestCrazyNesting),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_crazy_nesting_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestCrazyNestingType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a xception object */
static gint32
t_test_xception_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestXception * this_object = T_TEST_XCEPTION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->errorCode, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_errorCode = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->message != NULL)
          {
            g_free(this_object->message);
            this_object->message = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->message, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_message = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_xception_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestXception * this_object = T_TEST_XCEPTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Xception", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "errorCode", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->errorCode, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->message, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_xception_instance_init (TTestXception * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->errorCode = 0;
  object->__isset_errorCode = FALSE;
  object->message = NULL;
  object->__isset_message = FALSE;
}

static void 
t_test_xception_finalize (GObject *object)
{
  TTestXception *tobject = T_TEST_XCEPTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->message != NULL)
  {
    g_free (tobject->message);
    tobject->message = NULL;
  }
}

static void 
t_test_xception_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_xception_finalize;
  cls->read = t_test_xception_read;
  cls->write = t_test_xception_write;
}

GType
t_test_xception_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestXceptionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_xception_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestXception),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_xception_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestXceptionType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define T_TEST_XCEPTION_ERROR_DOMAIN "t_test_xception_error_quark"
GQuark
t_test_xception_error_quark (void)
{
  return g_quark_from_static_string (T_TEST_XCEPTION_ERROR_DOMAIN);
}

/* reads a xception2 object */
static gint32
t_test_xception2_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestXception2 * this_object = T_TEST_XCEPTION2(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->errorCode, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_errorCode = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->struct_thing), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_struct_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_xception2_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestXception2 * this_object = T_TEST_XCEPTION2(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Xception2", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "errorCode", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->errorCode, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "struct_thing", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->struct_thing), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_xception2_instance_init (TTestXception2 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->errorCode = 0;
  object->__isset_errorCode = FALSE;
  object->struct_thing = g_object_new (T_TEST_TYPE_XTRUCT, NULL);
  object->__isset_struct_thing = FALSE;
}

static void 
t_test_xception2_finalize (GObject *object)
{
  TTestXception2 *tobject = T_TEST_XCEPTION2 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->struct_thing != NULL)
  {
    g_object_unref(tobject->struct_thing);
    tobject->struct_thing = NULL;
  }
}

static void 
t_test_xception2_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_xception2_finalize;
  cls->read = t_test_xception2_read;
  cls->write = t_test_xception2_write;
}

GType
t_test_xception2_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestXception2Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_xception2_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestXception2),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_xception2_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestXception2Type",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define T_TEST_XCEPTION2_ERROR_DOMAIN "t_test_xception2_error_quark"
GQuark
t_test_xception2_error_quark (void)
{
  return g_quark_from_static_string (T_TEST_XCEPTION2_ERROR_DOMAIN);
}

/* reads a empty_struct object */
static gint32
t_test_empty_struct_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestEmptyStruct * this_object = T_TEST_EMPTY_STRUCT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_empty_struct_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestEmptyStruct * this_object = T_TEST_EMPTY_STRUCT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "EmptyStruct", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_empty_struct_instance_init (TTestEmptyStruct * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
t_test_empty_struct_finalize (GObject *object)
{
  TTestEmptyStruct *tobject = T_TEST_EMPTY_STRUCT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void 
t_test_empty_struct_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_empty_struct_finalize;
  cls->read = t_test_empty_struct_read;
  cls->write = t_test_empty_struct_write;
}

GType
t_test_empty_struct_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestEmptyStructClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_empty_struct_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestEmptyStruct),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_empty_struct_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestEmptyStructType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a one_field object */
static gint32
t_test_one_field_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestOneField * this_object = T_TEST_ONE_FIELD(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->field), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_one_field_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestOneField * this_object = T_TEST_ONE_FIELD(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "OneField", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "field", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->field), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_one_field_instance_init (TTestOneField * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->field = g_object_new (T_TEST_TYPE_EMPTY_STRUCT, NULL);
  object->__isset_field = FALSE;
}

static void 
t_test_one_field_finalize (GObject *object)
{
  TTestOneField *tobject = T_TEST_ONE_FIELD (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->field != NULL)
  {
    g_object_unref(tobject->field);
    tobject->field = NULL;
  }
}

static void 
t_test_one_field_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_one_field_finalize;
  cls->read = t_test_one_field_read;
  cls->write = t_test_one_field_write;
}

GType
t_test_one_field_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestOneFieldClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_one_field_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestOneField),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_one_field_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestOneFieldType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a versioning_test_v1 object */
static gint32
t_test_versioning_test_v1_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestVersioningTestV1 * this_object = T_TEST_VERSIONING_TEST_V1(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->begin_in_both, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_begin_in_both = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->old_string != NULL)
          {
            g_free(this_object->old_string);
            this_object->old_string = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->old_string, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_old_string = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->end_in_both, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_end_in_both = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_versioning_test_v1_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestVersioningTestV1 * this_object = T_TEST_VERSIONING_TEST_V1(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "VersioningTestV1", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "begin_in_both", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->begin_in_both, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "old_string", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->old_string, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "end_in_both", T_I32, 12, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->end_in_both, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_versioning_test_v1_instance_init (TTestVersioningTestV1 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->begin_in_both = 0;
  object->__isset_begin_in_both = FALSE;
  object->old_string = NULL;
  object->__isset_old_string = FALSE;
  object->end_in_both = 0;
  object->__isset_end_in_both = FALSE;
}

static void 
t_test_versioning_test_v1_finalize (GObject *object)
{
  TTestVersioningTestV1 *tobject = T_TEST_VERSIONING_TEST_V1 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->old_string != NULL)
  {
    g_free (tobject->old_string);
    tobject->old_string = NULL;
  }
}

static void 
t_test_versioning_test_v1_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_versioning_test_v1_finalize;
  cls->read = t_test_versioning_test_v1_read;
  cls->write = t_test_versioning_test_v1_write;
}

GType
t_test_versioning_test_v1_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestVersioningTestV1Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_versioning_test_v1_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestVersioningTestV1),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_versioning_test_v1_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestVersioningTestV1Type",
                                   &type_info, 0);
  }

  return type;
}

/* reads a versioning_test_v2 object */
static gint32
t_test_versioning_test_v2_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestVersioningTestV2 * this_object = T_TEST_VERSIONING_TEST_V2(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->begin_in_both, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_begin_in_both = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->newint, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_newint = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->newbyte, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_newbyte = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->newshort, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_newshort = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->newlong, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_newlong = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->newdouble, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_newdouble = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->newstruct), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_newstruct = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint32* _elem18 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem18, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->newlist, _elem18, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_newlist = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            guint32 i;
            for (i = 0; i < size; ++i)
            {
              gint32* _elem19 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem19, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *) this_object->newset, (gpointer) _elem19, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_newset = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint32* key20 = g_new (gint32, 1);
              gint32* val21 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*key20, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_i32 (protocol, &*val21, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->newmap, (gpointer) key20, (gpointer) val21);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_newmap = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_STRING)
        {
          if (this_object->newstring != NULL)
          {
            g_free(this_object->newstring);
            this_object->newstring = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->newstring, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_newstring = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->end_in_both, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_end_in_both = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_versioning_test_v2_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestVersioningTestV2 * this_object = T_TEST_VERSIONING_TEST_V2(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "VersioningTestV2", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "begin_in_both", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->begin_in_both, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "newint", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->newint, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "newbyte", T_BYTE, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->newbyte, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "newshort", T_I16, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->newshort, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "newlong", T_I64, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->newlong, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "newdouble", T_DOUBLE, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->newdouble, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "newstruct", T_STRUCT, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->newstruct), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "newlist", T_LIST, 8, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) this_object->newlist->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i22;
    for (i22=0; i22<this_object->newlist->len; i22++)
    {
      if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->newlist, gint32, i22)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "newset", T_SET, 9, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_set_begin (protocol, T_I32, (gint32) g_hash_table_size ((GHashTable *) this_object->newset), error)) < 0)
      return -1;
    xfer += ret;
    GList *key_list = NULL, *iter = NULL;
    gint32* elem;
    gpointer value;
    THRIFT_UNUSED_VAR (value);

    g_hash_table_foreach ((GHashTable *) this_object->newset, thrift_hash_table_get_keys, &key_list);
    gint32* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gint32*) iter->data;
    }
    g_list_free (key_list);

    for (i=0; i<key_count; ++i)
    {
      elem = keys[i];
      value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->newset), (gpointer) elem);

      if ((ret = thrift_protocol_write_i32 (protocol, *elem, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "newmap", T_MAP, 10, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_I32, (gint32) g_hash_table_size ((GHashTable *) this_object->newmap), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gint32* key;
    gint32* value;
    g_hash_table_foreach ((GHashTable *) this_object->newmap, thrift_hash_table_get_keys, &key_list);
    gint32* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gint32*) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (gint32*) g_hash_table_lookup (((GHashTable *) this_object->newmap), (gpointer) key);

      if ((ret = thrift_protocol_write_i32 (protocol, * key, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_i32 (protocol, * value, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "newstring", T_STRING, 11, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->newstring, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "end_in_both", T_I32, 12, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->end_in_both, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_versioning_test_v2_instance_init (TTestVersioningTestV2 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->begin_in_both = 0;
  object->__isset_begin_in_both = FALSE;
  object->newint = 0;
  object->__isset_newint = FALSE;
  object->newbyte = 0;
  object->__isset_newbyte = FALSE;
  object->newshort = 0;
  object->__isset_newshort = FALSE;
  object->newlong = 0;
  object->__isset_newlong = FALSE;
  object->newdouble = 0;
  object->__isset_newdouble = FALSE;
  object->newstruct = g_object_new (T_TEST_TYPE_BONK, NULL);
  object->__isset_newstruct = FALSE;
  object->newlist = g_array_new (0, 1, sizeof (gint32));
  object->__isset_newlist = FALSE;
  object->newset = g_hash_table_new_full (g_int_hash, g_int_equal, NULL, NULL);
  object->__isset_newset = FALSE;
  object->newmap = g_hash_table_new_full (g_int_hash, g_int_equal, NULL, NULL);
  object->__isset_newmap = FALSE;
  object->newstring = NULL;
  object->__isset_newstring = FALSE;
  object->end_in_both = 0;
  object->__isset_end_in_both = FALSE;
}

static void 
t_test_versioning_test_v2_finalize (GObject *object)
{
  TTestVersioningTestV2 *tobject = T_TEST_VERSIONING_TEST_V2 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->newstruct != NULL)
  {
    g_object_unref(tobject->newstruct);
    tobject->newstruct = NULL;
  }
  if (tobject->newlist != NULL)
  {
    g_array_free (tobject->newlist, TRUE);
    tobject->newlist = NULL;
  }
  if (tobject->newset != NULL)
  {
    g_hash_table_destroy (tobject->newset);
    tobject->newset = NULL;
  }
  if (tobject->newmap != NULL)
  {
    g_hash_table_destroy (tobject->newmap);
    tobject->newmap = NULL;
  }
  if (tobject->newstring != NULL)
  {
    g_free (tobject->newstring);
    tobject->newstring = NULL;
  }
}

static void 
t_test_versioning_test_v2_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_versioning_test_v2_finalize;
  cls->read = t_test_versioning_test_v2_read;
  cls->write = t_test_versioning_test_v2_write;
}

GType
t_test_versioning_test_v2_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestVersioningTestV2Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_versioning_test_v2_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestVersioningTestV2),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_versioning_test_v2_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestVersioningTestV2Type",
                                   &type_info, 0);
  }

  return type;
}

/* reads a list_type_versioning_v1 object */
static gint32
t_test_list_type_versioning_v1_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestListTypeVersioningV1 * this_object = T_TEST_LIST_TYPE_VERSIONING_V1(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint32* _elem23 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem23, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->myints, _elem23, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_myints = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->hello != NULL)
          {
            g_free(this_object->hello);
            this_object->hello = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->hello, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_hello = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_list_type_versioning_v1_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestListTypeVersioningV1 * this_object = T_TEST_LIST_TYPE_VERSIONING_V1(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ListTypeVersioningV1", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "myints", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) this_object->myints->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i24;
    for (i24=0; i24<this_object->myints->len; i24++)
    {
      if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->myints, gint32, i24)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "hello", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->hello, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_list_type_versioning_v1_instance_init (TTestListTypeVersioningV1 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->myints = g_array_new (0, 1, sizeof (gint32));
  object->__isset_myints = FALSE;
  object->hello = NULL;
  object->__isset_hello = FALSE;
}

static void 
t_test_list_type_versioning_v1_finalize (GObject *object)
{
  TTestListTypeVersioningV1 *tobject = T_TEST_LIST_TYPE_VERSIONING_V1 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->myints != NULL)
  {
    g_array_free (tobject->myints, TRUE);
    tobject->myints = NULL;
  }
  if (tobject->hello != NULL)
  {
    g_free (tobject->hello);
    tobject->hello = NULL;
  }
}

static void 
t_test_list_type_versioning_v1_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_list_type_versioning_v1_finalize;
  cls->read = t_test_list_type_versioning_v1_read;
  cls->write = t_test_list_type_versioning_v1_write;
}

GType
t_test_list_type_versioning_v1_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestListTypeVersioningV1Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_list_type_versioning_v1_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestListTypeVersioningV1),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_list_type_versioning_v1_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestListTypeVersioningV1Type",
                                   &type_info, 0);
  }

  return type;
}

/* reads a list_type_versioning_v2 object */
static gint32
t_test_list_type_versioning_v2_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestListTypeVersioningV2 * this_object = T_TEST_LIST_TYPE_VERSIONING_V2(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gchar * _elem25 = NULL;
              if (_elem25 != NULL)
              {
                g_free(_elem25);
                _elem25 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem25, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->strings, _elem25);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_strings = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->hello != NULL)
          {
            g_free(this_object->hello);
            this_object->hello = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->hello, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_hello = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_list_type_versioning_v2_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestListTypeVersioningV2 * this_object = T_TEST_LIST_TYPE_VERSIONING_V2(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ListTypeVersioningV2", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "strings", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) this_object->strings->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i26;
    for (i26=0; i26<this_object->strings->len; i26++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->strings, i26)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "hello", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->hello, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_list_type_versioning_v2_instance_init (TTestListTypeVersioningV2 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->strings = g_ptr_array_new_with_free_func (g_free);
  object->__isset_strings = FALSE;
  object->hello = NULL;
  object->__isset_hello = FALSE;
}

static void 
t_test_list_type_versioning_v2_finalize (GObject *object)
{
  TTestListTypeVersioningV2 *tobject = T_TEST_LIST_TYPE_VERSIONING_V2 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->strings != NULL)
  {
    g_ptr_array_free (tobject->strings, TRUE);
    tobject->strings = NULL;
  }
  if (tobject->hello != NULL)
  {
    g_free (tobject->hello);
    tobject->hello = NULL;
  }
}

static void 
t_test_list_type_versioning_v2_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_list_type_versioning_v2_finalize;
  cls->read = t_test_list_type_versioning_v2_read;
  cls->write = t_test_list_type_versioning_v2_write;
}

GType
t_test_list_type_versioning_v2_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestListTypeVersioningV2Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_list_type_versioning_v2_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestListTypeVersioningV2),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_list_type_versioning_v2_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestListTypeVersioningV2Type",
                                   &type_info, 0);
  }

  return type;
}

/* reads a guess_protocol_struct object */
static gint32
t_test_guess_protocol_struct_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestGuessProtocolStruct * this_object = T_TEST_GUESS_PROTOCOL_STRUCT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 7:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gchar * key27 = NULL;
              gchar * val28 = NULL;
              if (key27 != NULL)
              {
                g_free(key27);
                key27 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key27, error)) < 0)
                return -1;
              xfer += ret;
              if (val28 != NULL)
              {
                g_free(val28);
                val28 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val28, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->map_field, (gpointer) key27, (gpointer) val28);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_map_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_guess_protocol_struct_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestGuessProtocolStruct * this_object = T_TEST_GUESS_PROTOCOL_STRUCT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "GuessProtocolStruct", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "map_field", T_MAP, 7, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, (gint32) g_hash_table_size ((GHashTable *) this_object->map_field), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gchar * key;
    gchar * value;
    g_hash_table_foreach ((GHashTable *) this_object->map_field, thrift_hash_table_get_keys, &key_list);
    gchar * keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gchar *) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->map_field), (gpointer) key);

      if ((ret = thrift_protocol_write_string (protocol,  key, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_string (protocol,  value, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_guess_protocol_struct_instance_init (TTestGuessProtocolStruct * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->map_field = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_map_field = FALSE;
}

static void 
t_test_guess_protocol_struct_finalize (GObject *object)
{
  TTestGuessProtocolStruct *tobject = T_TEST_GUESS_PROTOCOL_STRUCT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->map_field != NULL)
  {
    g_hash_table_destroy (tobject->map_field);
    tobject->map_field = NULL;
  }
}

static void 
t_test_guess_protocol_struct_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_guess_protocol_struct_finalize;
  cls->read = t_test_guess_protocol_struct_read;
  cls->write = t_test_guess_protocol_struct_write;
}

GType
t_test_guess_protocol_struct_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestGuessProtocolStructClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_guess_protocol_struct_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestGuessProtocolStruct),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_guess_protocol_struct_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestGuessProtocolStructType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a large_deltas object */
static gint32
t_test_large_deltas_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestLargeDeltas * this_object = T_TEST_LARGE_DELTAS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->b1), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_b1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->b10), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_b10 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 100:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->b100), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_b100 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 500:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->check_true, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_check_true = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1000:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->b1000), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_b1000 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1500:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->check_false, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_check_false = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2000:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->vertwo2000), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_vertwo2000 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2500:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            guint32 i;
            for (i = 0; i < size; ++i)
            {
              gchar * _elem29 = NULL;
              if (_elem29 != NULL)
              {
                g_free(_elem29);
                _elem29 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem29, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *) this_object->a_set2500, (gpointer) _elem29, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_a_set2500 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3000:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->vertwo3000), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_vertwo3000 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4000:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint32* _elem30 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem30, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->big_numbers, _elem30, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_big_numbers = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_large_deltas_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestLargeDeltas * this_object = T_TEST_LARGE_DELTAS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "LargeDeltas", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "b1", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->b1), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "b10", T_STRUCT, 10, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->b10), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "b100", T_STRUCT, 100, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->b100), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "check_true", T_BOOL, 500, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->check_true, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "b1000", T_STRUCT, 1000, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->b1000), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "check_false", T_BOOL, 1500, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->check_false, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "vertwo2000", T_STRUCT, 2000, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->vertwo2000), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "a_set2500", T_SET, 2500, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_set_begin (protocol, T_STRING, (gint32) g_hash_table_size ((GHashTable *) this_object->a_set2500), error)) < 0)
      return -1;
    xfer += ret;
    GList *key_list = NULL, *iter = NULL;
    gchar * elem;
    gpointer value;
    THRIFT_UNUSED_VAR (value);

    g_hash_table_foreach ((GHashTable *) this_object->a_set2500, thrift_hash_table_get_keys, &key_list);
    gchar * keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gchar *) iter->data;
    }
    g_list_free (key_list);

    for (i=0; i<key_count; ++i)
    {
      elem = keys[i];
      value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->a_set2500), (gpointer) elem);

      if ((ret = thrift_protocol_write_string (protocol, elem, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "vertwo3000", T_STRUCT, 3000, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->vertwo3000), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "big_numbers", T_LIST, 4000, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) this_object->big_numbers->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i31;
    for (i31=0; i31<this_object->big_numbers->len; i31++)
    {
      if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->big_numbers, gint32, i31)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_large_deltas_instance_init (TTestLargeDeltas * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->b1 = g_object_new (T_TEST_TYPE_BOOLS, NULL);
  object->__isset_b1 = FALSE;
  object->b10 = g_object_new (T_TEST_TYPE_BOOLS, NULL);
  object->__isset_b10 = FALSE;
  object->b100 = g_object_new (T_TEST_TYPE_BOOLS, NULL);
  object->__isset_b100 = FALSE;
  object->check_true = 0;
  object->__isset_check_true = FALSE;
  object->b1000 = g_object_new (T_TEST_TYPE_BOOLS, NULL);
  object->__isset_b1000 = FALSE;
  object->check_false = 0;
  object->__isset_check_false = FALSE;
  object->vertwo2000 = g_object_new (T_TEST_TYPE_VERSIONING_TEST_V2, NULL);
  object->__isset_vertwo2000 = FALSE;
  object->a_set2500 = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
  object->__isset_a_set2500 = FALSE;
  object->vertwo3000 = g_object_new (T_TEST_TYPE_VERSIONING_TEST_V2, NULL);
  object->__isset_vertwo3000 = FALSE;
  object->big_numbers = g_array_new (0, 1, sizeof (gint32));
  object->__isset_big_numbers = FALSE;
}

static void 
t_test_large_deltas_finalize (GObject *object)
{
  TTestLargeDeltas *tobject = T_TEST_LARGE_DELTAS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->b1 != NULL)
  {
    g_object_unref(tobject->b1);
    tobject->b1 = NULL;
  }
  if (tobject->b10 != NULL)
  {
    g_object_unref(tobject->b10);
    tobject->b10 = NULL;
  }
  if (tobject->b100 != NULL)
  {
    g_object_unref(tobject->b100);
    tobject->b100 = NULL;
  }
  if (tobject->b1000 != NULL)
  {
    g_object_unref(tobject->b1000);
    tobject->b1000 = NULL;
  }
  if (tobject->vertwo2000 != NULL)
  {
    g_object_unref(tobject->vertwo2000);
    tobject->vertwo2000 = NULL;
  }
  if (tobject->a_set2500 != NULL)
  {
    g_hash_table_destroy (tobject->a_set2500);
    tobject->a_set2500 = NULL;
  }
  if (tobject->vertwo3000 != NULL)
  {
    g_object_unref(tobject->vertwo3000);
    tobject->vertwo3000 = NULL;
  }
  if (tobject->big_numbers != NULL)
  {
    g_array_free (tobject->big_numbers, TRUE);
    tobject->big_numbers = NULL;
  }
}

static void 
t_test_large_deltas_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_large_deltas_finalize;
  cls->read = t_test_large_deltas_read;
  cls->write = t_test_large_deltas_write;
}

GType
t_test_large_deltas_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestLargeDeltasClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_large_deltas_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestLargeDeltas),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_large_deltas_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestLargeDeltasType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a nested_lists_i32x2 object */
static gint32
t_test_nested_lists_i32x2_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestNestedListsI32x2 * this_object = T_TEST_NESTED_LISTS_I32X2(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              GArray * _elem32 = NULL;
              {
                guint32 size;
                ThriftType element_type;
                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                guint32 i;
                for (i = 0; i < size; i++)
                {
                  gint32* _elem33 = g_new (gint32, 1);
                  if ((ret = thrift_protocol_read_i32 (protocol, &*_elem33, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_array_append_vals (_elem32, _elem33, 1);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;

              }
              g_ptr_array_add (this_object->integerlist, _elem32);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_integerlist = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_nested_lists_i32x2_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestNestedListsI32x2 * this_object = T_TEST_NESTED_LISTS_I32X2(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NestedListsI32x2", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "integerlist", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_LIST, (gint32) this_object->integerlist->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i34;
    for (i34=0; i34<this_object->integerlist->len; i34++)
    {
      {
        if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) ((GArray*)g_ptr_array_index ((GPtrArray *) this_object->integerlist, i34))->len, error)) < 0)
          return -1;
        xfer += ret;
        guint i35;
        for (i35=0; i35<((GArray*)g_ptr_array_index ((GPtrArray *) this_object->integerlist, i34))->len; i35++)
        {
          if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (((GArray*)g_ptr_array_index ((GPtrArray *) this_object->integerlist, i34)), gint32, i35)), error)) < 0)
            return -1;
        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_nested_lists_i32x2_instance_init (TTestNestedListsI32x2 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->integerlist = g_ptr_array_new_with_free_func ((GDestroyNotify) g_array_unref);
  object->__isset_integerlist = FALSE;
}

static void 
t_test_nested_lists_i32x2_finalize (GObject *object)
{
  TTestNestedListsI32x2 *tobject = T_TEST_NESTED_LISTS_I32X2 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->integerlist != NULL)
  {
    g_ptr_array_free (tobject->integerlist, TRUE);
    tobject->integerlist = NULL;
  }
}

static void 
t_test_nested_lists_i32x2_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_nested_lists_i32x2_finalize;
  cls->read = t_test_nested_lists_i32x2_read;
  cls->write = t_test_nested_lists_i32x2_write;
}

GType
t_test_nested_lists_i32x2_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestNestedListsI32x2Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_nested_lists_i32x2_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestNestedListsI32x2),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_nested_lists_i32x2_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestNestedListsI32x2Type",
                                   &type_info, 0);
  }

  return type;
}

/* reads a nested_lists_i32x3 object */
static gint32
t_test_nested_lists_i32x3_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestNestedListsI32x3 * this_object = T_TEST_NESTED_LISTS_I32X3(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              GPtrArray * _elem36 = NULL;
              {
                guint32 size;
                ThriftType element_type;
                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                guint32 i;
                for (i = 0; i < size; i++)
                {
                  GArray * _elem37 = NULL;
                  {
                    guint32 size;
                    ThriftType element_type;
                    if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
                      return -1;
                    xfer += ret;

                    /* iterate through list elements */
                    guint32 i;
                    for (i = 0; i < size; i++)
                    {
                      gint32* _elem38 = g_new (gint32, 1);
                      if ((ret = thrift_protocol_read_i32 (protocol, &*_elem38, error)) < 0)
                        return -1;
                      xfer += ret;
                      g_array_append_vals (_elem37, _elem38, 1);
                    }
                    if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                      return -1;
                    xfer += ret;

                  }
                  g_ptr_array_add (_elem36, _elem37);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;

              }
              g_ptr_array_add (this_object->integerlist, _elem36);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_integerlist = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_nested_lists_i32x3_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestNestedListsI32x3 * this_object = T_TEST_NESTED_LISTS_I32X3(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NestedListsI32x3", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "integerlist", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_LIST, (gint32) this_object->integerlist->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i39;
    for (i39=0; i39<this_object->integerlist->len; i39++)
    {
      {
        if ((ret = thrift_protocol_write_list_begin (protocol, T_LIST, (gint32) ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->integerlist, i39))->len, error)) < 0)
          return -1;
        xfer += ret;
        guint i40;
        for (i40=0; i40<((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->integerlist, i39))->len; i40++)
        {
          {
            if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) ((GArray*)g_ptr_array_index ((GPtrArray *) ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->integerlist, i39)), i40))->len, error)) < 0)
              return -1;
            xfer += ret;
            guint i41;
            for (i41=0; i41<((GArray*)g_ptr_array_index ((GPtrArray *) ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->integerlist, i39)), i40))->len; i41++)
            {
              if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (((GArray*)g_ptr_array_index ((GPtrArray *) ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->integerlist, i39)), i40)), gint32, i41)), error)) < 0)
                return -1;
            }
            if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_nested_lists_i32x3_instance_init (TTestNestedListsI32x3 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->integerlist = g_ptr_array_new_with_free_func ((GDestroyNotify) g_ptr_array_unref);
  object->__isset_integerlist = FALSE;
}

static void 
t_test_nested_lists_i32x3_finalize (GObject *object)
{
  TTestNestedListsI32x3 *tobject = T_TEST_NESTED_LISTS_I32X3 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->integerlist != NULL)
  {
    g_ptr_array_free (tobject->integerlist, TRUE);
    tobject->integerlist = NULL;
  }
}

static void 
t_test_nested_lists_i32x3_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_nested_lists_i32x3_finalize;
  cls->read = t_test_nested_lists_i32x3_read;
  cls->write = t_test_nested_lists_i32x3_write;
}

GType
t_test_nested_lists_i32x3_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestNestedListsI32x3Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_nested_lists_i32x3_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestNestedListsI32x3),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_nested_lists_i32x3_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestNestedListsI32x3Type",
                                   &type_info, 0);
  }

  return type;
}

/* reads a nested_mixedx2 object */
static gint32
t_test_nested_mixedx2_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestNestedMixedx2 * this_object = T_TEST_NESTED_MIXEDX2(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              GHashTable * _elem42 = NULL;
              {
                guint32 size;
                ThriftType element_type;
                if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through the set elements */
                guint32 i;
                for (i = 0; i < size; ++i)
                {
                  gint32* _elem43 = g_new (gint32, 1);
                  if ((ret = thrift_protocol_read_i32 (protocol, &*_elem43, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_hash_table_insert ((GHashTable *) _elem42, (gpointer) _elem43, (gpointer) 1);
                }
                if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;

              }
              g_ptr_array_add (this_object->int_set_list, _elem42);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_int_set_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint32* key44 = g_new (gint32, 1);
              GHashTable * val45 = NULL;
              if ((ret = thrift_protocol_read_i32 (protocol, &*key44, error)) < 0)
                return -1;
              xfer += ret;
              {
                guint32 size;
                ThriftType element_type;
                if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through the set elements */
                guint32 i;
                for (i = 0; i < size; ++i)
                {
                  gchar * _elem46 = NULL;
                  if (_elem46 != NULL)
                  {
                    g_free(_elem46);
                    _elem46 = NULL;
                  }

                  if ((ret = thrift_protocol_read_string (protocol, &_elem46, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_hash_table_insert ((GHashTable *) val45, (gpointer) _elem46, (gpointer) 1);
                }
                if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;

              }
              g_hash_table_insert ((GHashTable *)this_object->map_int_strset, (gpointer) key44, (gpointer) val45);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_map_int_strset = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              GHashTable * _elem47 = g_hash_table_new (NULL, NULL);
              {
                guint32 size;
                ThriftType key_type;
                ThriftType value_type;

                /* read the map begin marker */
                if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through each of the map's fields */
                guint32 i;
                for (i = 0; i < size; i++)
                {
                  gint32* key48 = g_new (gint32, 1);
                  GHashTable * val49 = NULL;
                  if ((ret = thrift_protocol_read_i32 (protocol, &*key48, error)) < 0)
                    return -1;
                  xfer += ret;
                  {
                    guint32 size;
                    ThriftType element_type;
                    if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
                      return -1;
                    xfer += ret;

                    /* iterate through the set elements */
                    guint32 i;
                    for (i = 0; i < size; ++i)
                    {
                      gchar * _elem50 = NULL;
                      if (_elem50 != NULL)
                      {
                        g_free(_elem50);
                        _elem50 = NULL;
                      }

                      if ((ret = thrift_protocol_read_string (protocol, &_elem50, error)) < 0)
                        return -1;
                      xfer += ret;
                      g_hash_table_insert ((GHashTable *) val49, (gpointer) _elem50, (gpointer) 1);
                    }
                    if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
                      return -1;
                    xfer += ret;

                  }
                  g_hash_table_insert ((GHashTable *)_elem47, (gpointer) key48, (gpointer) val49);
                }

                /* read the map end marker */
                if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              g_ptr_array_add (this_object->map_int_strset_list, _elem47);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_map_int_strset_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_nested_mixedx2_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestNestedMixedx2 * this_object = T_TEST_NESTED_MIXEDX2(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NestedMixedx2", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "int_set_list", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_SET, (gint32) this_object->int_set_list->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i51;
    for (i51=0; i51<this_object->int_set_list->len; i51++)
    {
      {
        if ((ret = thrift_protocol_write_set_begin (protocol, T_I32, (gint32) g_hash_table_size ((GHashTable *) ((GHashTable*)g_ptr_array_index ((GPtrArray *) this_object->int_set_list, i51))), error)) < 0)
          return -1;
        xfer += ret;
        GList *key_list = NULL, *iter = NULL;
        gint32* elem;
        gpointer value;
        THRIFT_UNUSED_VAR (value);

        g_hash_table_foreach ((GHashTable *) ((GHashTable*)g_ptr_array_index ((GPtrArray *) this_object->int_set_list, i51)), thrift_hash_table_get_keys, &key_list);
        gint32* keys[g_list_length (key_list)];
        int i=0, key_count = g_list_length (key_list);
        for (iter = g_list_first (key_list); iter; iter = iter->next)
        {
          keys[i++] = (gint32*) iter->data;
        }
        g_list_free (key_list);

        for (i=0; i<key_count; ++i)
        {
          elem = keys[i];
          value = (gpointer) g_hash_table_lookup (((GHashTable *) ((GHashTable*)g_ptr_array_index ((GPtrArray *) this_object->int_set_list, i51))), (gpointer) elem);

          if ((ret = thrift_protocol_write_i32 (protocol, *elem, error)) < 0)
            return -1;
        }
        if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "map_int_strset", T_MAP, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_SET, (gint32) g_hash_table_size ((GHashTable *) this_object->map_int_strset), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gint32* key;
    GHashTable * value;
    g_hash_table_foreach ((GHashTable *) this_object->map_int_strset, thrift_hash_table_get_keys, &key_list);
    gint32* keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gint32*) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (GHashTable *) g_hash_table_lookup (((GHashTable *) this_object->map_int_strset), (gpointer) key);

      if ((ret = thrift_protocol_write_i32 (protocol, * key, error)) < 0)
        return -1;
      {
        if ((ret = thrift_protocol_write_set_begin (protocol, T_STRING, (gint32) g_hash_table_size ((GHashTable *)  value), error)) < 0)
          return -1;
        xfer += ret;
        GList *key_list = NULL, *iter = NULL;
        gchar * elem;
        gpointer value;
        THRIFT_UNUSED_VAR (value);

        g_hash_table_foreach ((GHashTable *)  value, thrift_hash_table_get_keys, &key_list);
        gchar * keys[g_list_length (key_list)];
        int i=0, key_count = g_list_length (key_list);
        for (iter = g_list_first (key_list); iter; iter = iter->next)
        {
          keys[i++] = (gchar *) iter->data;
        }
        g_list_free (key_list);

        for (i=0; i<key_count; ++i)
        {
          elem = keys[i];
          value = (gpointer) g_hash_table_lookup (((GHashTable *)  value), (gpointer) elem);

          if ((ret = thrift_protocol_write_string (protocol, elem, error)) < 0)
            return -1;
        }
        if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "map_int_strset_list", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_MAP, (gint32) this_object->map_int_strset_list->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i52;
    for (i52=0; i52<this_object->map_int_strset_list->len; i52++)
    {
      {
        if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_SET, (gint32) g_hash_table_size ((GHashTable *) ((GHashTable*)g_ptr_array_index ((GPtrArray *) this_object->map_int_strset_list, i52))), error)) < 0)
          return -1;
        xfer += ret;

        GList *key_list = NULL, *iter = NULL;
        gint32* key;
        GHashTable * value;
        g_hash_table_foreach ((GHashTable *) ((GHashTable*)g_ptr_array_index ((GPtrArray *) this_object->map_int_strset_list, i52)), thrift_hash_table_get_keys, &key_list);
        gint32* keys[g_list_length (key_list)];
        int i=0, key_count = g_list_length (key_list);
        for (iter = g_list_first (key_list); iter; iter = iter->next)
        {
          keys[i++] = (gint32*) iter->data;
        }
        g_list_free (key_list);

        for (i = 0; i < key_count; ++i)
        {
          key = keys[i];
          value = (GHashTable *) g_hash_table_lookup (((GHashTable *) ((GHashTable*)g_ptr_array_index ((GPtrArray *) this_object->map_int_strset_list, i52))), (gpointer) key);

          if ((ret = thrift_protocol_write_i32 (protocol, * key, error)) < 0)
            return -1;
          {
            if ((ret = thrift_protocol_write_set_begin (protocol, T_STRING, (gint32) g_hash_table_size ((GHashTable *)  value), error)) < 0)
              return -1;
            xfer += ret;
            GList *key_list = NULL, *iter = NULL;
            gchar * elem;
            gpointer value;
            THRIFT_UNUSED_VAR (value);

            g_hash_table_foreach ((GHashTable *)  value, thrift_hash_table_get_keys, &key_list);
            gchar * keys[g_list_length (key_list)];
            int i=0, key_count = g_list_length (key_list);
            for (iter = g_list_first (key_list); iter; iter = iter->next)
            {
              keys[i++] = (gchar *) iter->data;
            }
            g_list_free (key_list);

            for (i=0; i<key_count; ++i)
            {
              elem = keys[i];
              value = (gpointer) g_hash_table_lookup (((GHashTable *)  value), (gpointer) elem);

              if ((ret = thrift_protocol_write_string (protocol, elem, error)) < 0)
                return -1;
            }
            if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
        }
        if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_nested_mixedx2_instance_init (TTestNestedMixedx2 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->int_set_list = g_ptr_array_new_with_free_func ((GDestroyNotify) g_hash_table_destroy);
  object->__isset_int_set_list = FALSE;
  object->map_int_strset = g_hash_table_new_full (g_int_hash, g_int_equal, NULL, (GDestroyNotify) g_hash_table_destroy);
  object->__isset_map_int_strset = FALSE;
  object->map_int_strset_list = g_ptr_array_new_with_free_func ((GDestroyNotify) g_hash_table_destroy);
  object->__isset_map_int_strset_list = FALSE;
}

static void 
t_test_nested_mixedx2_finalize (GObject *object)
{
  TTestNestedMixedx2 *tobject = T_TEST_NESTED_MIXEDX2 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->int_set_list != NULL)
  {
    g_ptr_array_free (tobject->int_set_list, TRUE);
    tobject->int_set_list = NULL;
  }
  if (tobject->map_int_strset != NULL)
  {
    g_hash_table_destroy (tobject->map_int_strset);
    tobject->map_int_strset = NULL;
  }
  if (tobject->map_int_strset_list != NULL)
  {
    g_ptr_array_free (tobject->map_int_strset_list, TRUE);
    tobject->map_int_strset_list = NULL;
  }
}

static void 
t_test_nested_mixedx2_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_nested_mixedx2_finalize;
  cls->read = t_test_nested_mixedx2_read;
  cls->write = t_test_nested_mixedx2_write;
}

GType
t_test_nested_mixedx2_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestNestedMixedx2Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_nested_mixedx2_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestNestedMixedx2),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_nested_mixedx2_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestNestedMixedx2Type",
                                   &type_info, 0);
  }

  return type;
}

/* reads a list_bonks object */
static gint32
t_test_list_bonks_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestListBonks * this_object = T_TEST_LIST_BONKS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              TTestBonk * _elem53 = NULL;
              if ( _elem53 != NULL)
              {
                g_object_unref (_elem53);
              }
              _elem53 = g_object_new (T_TEST_TYPE_BONK, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem53), protocol, error)) < 0)
              {
                g_object_unref (_elem53);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->bonk, _elem53);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_bonk = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_list_bonks_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestListBonks * this_object = T_TEST_LIST_BONKS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ListBonks", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "bonk", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->bonk->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i54;
    for (i54=0; i54<this_object->bonk->len; i54++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->bonk, i54))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_list_bonks_instance_init (TTestListBonks * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->bonk = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_bonk = FALSE;
}

static void 
t_test_list_bonks_finalize (GObject *object)
{
  TTestListBonks *tobject = T_TEST_LIST_BONKS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->bonk != NULL)
  {
    g_ptr_array_free (tobject->bonk, TRUE);
    tobject->bonk = NULL;
  }
}

static void 
t_test_list_bonks_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_list_bonks_finalize;
  cls->read = t_test_list_bonks_read;
  cls->write = t_test_list_bonks_write;
}

GType
t_test_list_bonks_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestListBonksClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_list_bonks_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestListBonks),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_list_bonks_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestListBonksType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a nested_lists_bonk object */
static gint32
t_test_nested_lists_bonk_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestNestedListsBonk * this_object = T_TEST_NESTED_LISTS_BONK(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              GPtrArray * _elem55 = NULL;
              {
                guint32 size;
                ThriftType element_type;
                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                guint32 i;
                for (i = 0; i < size; i++)
                {
                  GPtrArray * _elem56 = NULL;
                  {
                    guint32 size;
                    ThriftType element_type;
                    if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
                      return -1;
                    xfer += ret;

                    /* iterate through list elements */
                    guint32 i;
                    for (i = 0; i < size; i++)
                    {
                      TTestBonk * _elem57 = NULL;
                      if ( _elem57 != NULL)
                      {
                        g_object_unref (_elem57);
                      }
                      _elem57 = g_object_new (T_TEST_TYPE_BONK, NULL);
                      if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem57), protocol, error)) < 0)
                      {
                        g_object_unref (_elem57);
                        return -1;
                      }
                      xfer += ret;
                      g_ptr_array_add (_elem56, _elem57);
                    }
                    if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                      return -1;
                    xfer += ret;

                  }
                  g_ptr_array_add (_elem55, _elem56);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;

              }
              g_ptr_array_add (this_object->bonk, _elem55);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_bonk = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_nested_lists_bonk_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestNestedListsBonk * this_object = T_TEST_NESTED_LISTS_BONK(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NestedListsBonk", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "bonk", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_LIST, (gint32) this_object->bonk->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i58;
    for (i58=0; i58<this_object->bonk->len; i58++)
    {
      {
        if ((ret = thrift_protocol_write_list_begin (protocol, T_LIST, (gint32) ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->bonk, i58))->len, error)) < 0)
          return -1;
        xfer += ret;
        guint i59;
        for (i59=0; i59<((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->bonk, i58))->len; i59++)
        {
          {
            if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) ((GPtrArray*)g_ptr_array_index ((GPtrArray *) ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->bonk, i58)), i59))->len, error)) < 0)
              return -1;
            xfer += ret;
            guint i60;
            for (i60=0; i60<((GPtrArray*)g_ptr_array_index ((GPtrArray *) ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->bonk, i58)), i59))->len; i60++)
            {
              if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) ((GPtrArray*)g_ptr_array_index ((GPtrArray *) ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->bonk, i58)), i59)), i60))), protocol, error)) < 0)
                return -1;
              xfer += ret;

            }
            if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_nested_lists_bonk_instance_init (TTestNestedListsBonk * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->bonk = g_ptr_array_new_with_free_func ((GDestroyNotify) g_ptr_array_unref);
  object->__isset_bonk = FALSE;
}

static void 
t_test_nested_lists_bonk_finalize (GObject *object)
{
  TTestNestedListsBonk *tobject = T_TEST_NESTED_LISTS_BONK (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->bonk != NULL)
  {
    g_ptr_array_free (tobject->bonk, TRUE);
    tobject->bonk = NULL;
  }
}

static void 
t_test_nested_lists_bonk_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_nested_lists_bonk_finalize;
  cls->read = t_test_nested_lists_bonk_read;
  cls->write = t_test_nested_lists_bonk_write;
}

GType
t_test_nested_lists_bonk_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestNestedListsBonkClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_nested_lists_bonk_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestNestedListsBonk),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_nested_lists_bonk_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestNestedListsBonkType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a bool_test object */
static gint32
t_test_bool_test_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestBoolTest * this_object = T_TEST_BOOL_TEST(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->b, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_b = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->s != NULL)
          {
            g_free(this_object->s);
            this_object->s = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->s, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_s = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_bool_test_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestBoolTest * this_object = T_TEST_BOOL_TEST(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BoolTest", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_b == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "b", T_BOOL, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->b, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_s == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "s", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->s, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_bool_test_instance_init (TTestBoolTest * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->b = 1;
  object->__isset_b = FALSE;
  object->s = g_strdup ("true");
  object->__isset_s = FALSE;
}

static void 
t_test_bool_test_finalize (GObject *object)
{
  TTestBoolTest *tobject = T_TEST_BOOL_TEST (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->s != NULL)
  {
    g_free (tobject->s);
    tobject->s = NULL;
  }
}

static void 
t_test_bool_test_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_bool_test_finalize;
  cls->read = t_test_bool_test_read;
  cls->write = t_test_bool_test_write;
}

GType
t_test_bool_test_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestBoolTestClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_bool_test_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestBoolTest),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_bool_test_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestBoolTestType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a struct_a object */
static gint32
t_test_struct_a_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestStructA * this_object = T_TEST_STRUCT_A(object);
  gboolean isset_s = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->s != NULL)
          {
            g_free(this_object->s);
            this_object->s = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->s, error)) < 0)
            return -1;
          xfer += ret;
          isset_s = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_s)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_test_struct_a_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestStructA * this_object = T_TEST_STRUCT_A(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "StructA", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "s", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->s, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_struct_a_instance_init (TTestStructA * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->s = NULL;
}

static void 
t_test_struct_a_finalize (GObject *object)
{
  TTestStructA *tobject = T_TEST_STRUCT_A (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->s != NULL)
  {
    g_free (tobject->s);
    tobject->s = NULL;
  }
}

static void 
t_test_struct_a_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_struct_a_finalize;
  cls->read = t_test_struct_a_read;
  cls->write = t_test_struct_a_write;
}

GType
t_test_struct_a_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestStructAClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_struct_a_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestStructA),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_struct_a_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestStructAType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a struct_b object */
static gint32
t_test_struct_b_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestStructB * this_object = T_TEST_STRUCT_B(object);
  gboolean isset_ab = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->aa), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_aa = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ab), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_ab = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_ab)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_test_struct_b_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestStructB * this_object = T_TEST_STRUCT_B(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "StructB", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_aa == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "aa", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->aa), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "ab", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ab), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_struct_b_instance_init (TTestStructB * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->aa = g_object_new (T_TEST_TYPE_STRUCT_A, NULL);
  object->__isset_aa = FALSE;
  object->ab = g_object_new (T_TEST_TYPE_STRUCT_A, NULL);
}

static void 
t_test_struct_b_finalize (GObject *object)
{
  TTestStructB *tobject = T_TEST_STRUCT_B (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->aa != NULL)
  {
    g_object_unref(tobject->aa);
    tobject->aa = NULL;
  }
  if (tobject->ab != NULL)
  {
    g_object_unref(tobject->ab);
    tobject->ab = NULL;
  }
}

static void 
t_test_struct_b_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = t_test_struct_b_finalize;
  cls->read = t_test_struct_b_read;
  cls->write = t_test_struct_b_write;
}

GType
t_test_struct_b_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestStructBClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_struct_b_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestStructB),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_struct_b_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestStructBType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */

