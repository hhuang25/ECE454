/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include <string.h>
#include <thrift/c_glib/thrift.h>
#include <thrift/c_glib/thrift_application_exception.h>
#include "t_test_thrift_test.h"

gboolean
t_test_thrift_test_if_test_void (TTestThriftTestIf *iface, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_void (iface, error);
}

gboolean
t_test_thrift_test_if_test_string (TTestThriftTestIf *iface, gchar ** _return, const gchar * thing, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_string (iface, _return, thing, error);
}

gboolean
t_test_thrift_test_if_test_byte (TTestThriftTestIf *iface, gint8* _return, const gint8 thing, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_byte (iface, _return, thing, error);
}

gboolean
t_test_thrift_test_if_test_i32 (TTestThriftTestIf *iface, gint32* _return, const gint32 thing, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_i32 (iface, _return, thing, error);
}

gboolean
t_test_thrift_test_if_test_i64 (TTestThriftTestIf *iface, gint64* _return, const gint64 thing, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_i64 (iface, _return, thing, error);
}

gboolean
t_test_thrift_test_if_test_double (TTestThriftTestIf *iface, gdouble* _return, const gdouble thing, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_double (iface, _return, thing, error);
}

gboolean
t_test_thrift_test_if_test_struct (TTestThriftTestIf *iface, TTestXtruct ** _return, const TTestXtruct * thing, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_struct (iface, _return, thing, error);
}

gboolean
t_test_thrift_test_if_test_nest (TTestThriftTestIf *iface, TTestXtruct2 ** _return, const TTestXtruct2 * thing, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_nest (iface, _return, thing, error);
}

gboolean
t_test_thrift_test_if_test_map (TTestThriftTestIf *iface, GHashTable ** _return, const GHashTable * thing, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_map (iface, _return, thing, error);
}

gboolean
t_test_thrift_test_if_test_string_map (TTestThriftTestIf *iface, GHashTable ** _return, const GHashTable * thing, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_string_map (iface, _return, thing, error);
}

gboolean
t_test_thrift_test_if_test_set (TTestThriftTestIf *iface, GHashTable ** _return, const GHashTable * thing, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_set (iface, _return, thing, error);
}

gboolean
t_test_thrift_test_if_test_list (TTestThriftTestIf *iface, GArray ** _return, const GArray * thing, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_list (iface, _return, thing, error);
}

gboolean
t_test_thrift_test_if_test_enum (TTestThriftTestIf *iface, TTestNumberz* _return, const TTestNumberz thing, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_enum (iface, _return, thing, error);
}

gboolean
t_test_thrift_test_if_test_typedef (TTestThriftTestIf *iface, TTestUserId* _return, const TTestUserId thing, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_typedef (iface, _return, thing, error);
}

gboolean
t_test_thrift_test_if_test_map_map (TTestThriftTestIf *iface, GHashTable ** _return, const gint32 hello, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_map_map (iface, _return, hello, error);
}

gboolean
t_test_thrift_test_if_test_insanity (TTestThriftTestIf *iface, GHashTable ** _return, const TTestInsanity * argument, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_insanity (iface, _return, argument, error);
}

gboolean
t_test_thrift_test_if_test_multi (TTestThriftTestIf *iface, TTestXtruct ** _return, const gint8 arg0, const gint32 arg1, const gint64 arg2, const GHashTable * arg3, const TTestNumberz arg4, const TTestUserId arg5, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_multi (iface, _return, arg0, arg1, arg2, arg3, arg4, arg5, error);
}

gboolean
t_test_thrift_test_if_test_exception (TTestThriftTestIf *iface, const gchar * arg, TTestXception ** err1, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_exception (iface, arg, err1, error);
}

gboolean
t_test_thrift_test_if_test_multi_exception (TTestThriftTestIf *iface, TTestXtruct ** _return, const gchar * arg0, const gchar * arg1, TTestXception ** err1, TTestXception2 ** err2, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_multi_exception (iface, _return, arg0, arg1, err1, err2, error);
}

gboolean
t_test_thrift_test_if_test_oneway (TTestThriftTestIf *iface, const gint32 secondsToSleep, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_oneway (iface, secondsToSleep, error);
}

GType
t_test_thrift_test_if_get_type (void)
{
  static GType type = 0;
  if (type == 0)
  {
    static const GTypeInfo type_info =
    {
      sizeof (TTestThriftTestIfInterface),
      NULL,  /* base_init */
      NULL,  /* base_finalize */
      NULL,  /* class_init */
      NULL,  /* class_finalize */
      NULL,  /* class_data */
      0,     /* instance_size */
      0,     /* n_preallocs */
      NULL,  /* instance_init */
      NULL   /* value_table */
    };
    type = g_type_register_static (G_TYPE_INTERFACE,
                                   "TTestThriftTestIf",
                                   &type_info, 0);
  }
  return type;
}

static void 
t_test_thrift_test_if_interface_init (TTestThriftTestIfInterface *iface);

G_DEFINE_TYPE_WITH_CODE (TTestThriftTestClient, t_test_thrift_test_client,
                       G_TYPE_OBJECT, 
                         G_IMPLEMENT_INTERFACE (T_TEST_TYPE_THRIFT_TEST_IF,
                                                t_test_thrift_test_if_interface_init));

enum _TTestThriftTestClientProperties
{
  PROP_0,
  PROP_T_TEST_THRIFT_TEST_CLIENT_INPUT_PROTOCOL,
  PROP_T_TEST_THRIFT_TEST_CLIENT_OUTPUT_PROTOCOL
};

void
t_test_thrift_test_client_set_property (GObject *object, guint property_id, const GValue *value, GParamSpec *pspec)
{
  TTestThriftTestClient *client = T_TEST_THRIFT_TEST_CLIENT (object);

  THRIFT_UNUSED_VAR (pspec);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_CLIENT_INPUT_PROTOCOL:
      client->input_protocol = g_value_get_object (value);
      break;
    case PROP_T_TEST_THRIFT_TEST_CLIENT_OUTPUT_PROTOCOL:
      client->output_protocol = g_value_get_object (value);
      break;
  }
}

void
t_test_thrift_test_client_get_property (GObject *object, guint property_id, GValue *value, GParamSpec *pspec)
{
  TTestThriftTestClient *client = T_TEST_THRIFT_TEST_CLIENT (object);

  THRIFT_UNUSED_VAR (pspec);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_CLIENT_INPUT_PROTOCOL:
      g_value_set_object (value, client->input_protocol);
      break;
    case PROP_T_TEST_THRIFT_TEST_CLIENT_OUTPUT_PROTOCOL:
      g_value_set_object (value, client->output_protocol);
      break;
  }
}

gboolean t_test_thrift_test_client_send_test_void (TTestThriftTestIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testVoid", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testVoid_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_void (TTestThriftTestIf * iface, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0)
  {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    ThriftApplicationException *xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testVoid", 8) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testVoid", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_void (TTestThriftTestIf * iface, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_void (iface, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_void (iface, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_string (TTestThriftTestIf * iface, const gchar * thing, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testString", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testString_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, thing, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_string (TTestThriftTestIf * iface, gchar ** _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0)
  {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    ThriftApplicationException *xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testString", 10) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testString", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_string (TTestThriftTestIf * iface, gchar ** _return, const gchar * thing, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_string (iface, thing, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_string (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_byte (TTestThriftTestIf * iface, const gint8 thing, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testByte", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testByte_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_BYTE, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_byte (protocol, thing, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_byte (TTestThriftTestIf * iface, gint8* _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0)
  {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    ThriftApplicationException *xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testByte", 8) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testByte", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_BYTE)
          {
            if ((ret = thrift_protocol_read_byte (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_byte (TTestThriftTestIf * iface, gint8* _return, const gint8 thing, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_byte (iface, thing, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_byte (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_i32 (TTestThriftTestIf * iface, const gint32 thing, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testI32", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testI32_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, thing, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_i32 (TTestThriftTestIf * iface, gint32* _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0)
  {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    ThriftApplicationException *xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testI32", 7) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testI32", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_i32 (TTestThriftTestIf * iface, gint32* _return, const gint32 thing, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_i32 (iface, thing, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_i32 (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_i64 (TTestThriftTestIf * iface, const gint64 thing, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testI64", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testI64_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, thing, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_i64 (TTestThriftTestIf * iface, gint64* _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0)
  {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    ThriftApplicationException *xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testI64", 7) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testI64", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I64)
          {
            if ((ret = thrift_protocol_read_i64 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_i64 (TTestThriftTestIf * iface, gint64* _return, const gint64 thing, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_i64 (iface, thing, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_i64 (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_double (TTestThriftTestIf * iface, const gdouble thing, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testDouble", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testDouble_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_DOUBLE, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_double (protocol, thing, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_double (TTestThriftTestIf * iface, gdouble* _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0)
  {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    ThriftApplicationException *xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testDouble", 10) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testDouble", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_DOUBLE)
          {
            if ((ret = thrift_protocol_read_double (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_double (TTestThriftTestIf * iface, gdouble* _return, const gdouble thing, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_double (iface, thing, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_double (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_struct (TTestThriftTestIf * iface, const TTestXtruct * thing, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testStruct", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testStruct_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (thing), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_struct (TTestThriftTestIf * iface, TTestXtruct ** _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0)
  {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    ThriftApplicationException *xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testStruct", 10) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testStruct", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_struct (TTestThriftTestIf * iface, TTestXtruct ** _return, const TTestXtruct * thing, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_struct (iface, thing, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_struct (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_nest (TTestThriftTestIf * iface, const TTestXtruct2 * thing, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testNest", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testNest_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (thing), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_nest (TTestThriftTestIf * iface, TTestXtruct2 ** _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0)
  {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    ThriftApplicationException *xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testNest", 8) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testNest", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_nest (TTestThriftTestIf * iface, TTestXtruct2 ** _return, const TTestXtruct2 * thing, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_nest (iface, thing, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_nest (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_map (TTestThriftTestIf * iface, const GHashTable * thing, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testMap", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testMap_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_MAP, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_I32, (gint32) g_hash_table_size ((GHashTable *) thing), error)) < 0)
        return 0;
      xfer += ret;

      GList *key_list = NULL, *iter = NULL;
      gint32* key;
      gint32* value;
      g_hash_table_foreach ((GHashTable *) thing, thrift_hash_table_get_keys, &key_list);
      gint32* keys[g_list_length (key_list)];
      int i=0, key_count = g_list_length (key_list);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
      {
        keys[i++] = (gint32*) iter->data;
      }
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key = keys[i];
        value = (gint32*) g_hash_table_lookup (((GHashTable *) thing), (gpointer) key);

        if ((ret = thrift_protocol_write_i32 (protocol, * key, error)) < 0)
          return 0;
        if ((ret = thrift_protocol_write_i32 (protocol, * value, error)) < 0)
          return 0;
      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_map (TTestThriftTestIf * iface, GHashTable ** _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0)
  {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    ThriftApplicationException *xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testMap", 7) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testMap", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_MAP)
          {
            {
              guint32 size;
              ThriftType key_type;
              ThriftType value_type;

              /* read the map begin marker */
              if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through each of the map's fields */
              guint32 i;
              for (i = 0; i < size; i++)
              {
                gint32* key61 = g_new (gint32, 1);
                gint32* val62 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*key61, error)) < 0)
                  return 0;
                xfer += ret;
                if ((ret = thrift_protocol_read_i32 (protocol, &*val62, error)) < 0)
                  return 0;
                xfer += ret;
                g_hash_table_insert ((GHashTable *)*_return, (gpointer) key61, (gpointer) val62);
              }

              /* read the map end marker */
              if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_map (TTestThriftTestIf * iface, GHashTable ** _return, const GHashTable * thing, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_map (iface, thing, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_map (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_string_map (TTestThriftTestIf * iface, const GHashTable * thing, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testStringMap", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testStringMap_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_MAP, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, (gint32) g_hash_table_size ((GHashTable *) thing), error)) < 0)
        return 0;
      xfer += ret;

      GList *key_list = NULL, *iter = NULL;
      gchar * key;
      gchar * value;
      g_hash_table_foreach ((GHashTable *) thing, thrift_hash_table_get_keys, &key_list);
      gchar * keys[g_list_length (key_list)];
      int i=0, key_count = g_list_length (key_list);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
      {
        keys[i++] = (gchar *) iter->data;
      }
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key = keys[i];
        value = (gchar *) g_hash_table_lookup (((GHashTable *) thing), (gpointer) key);

        if ((ret = thrift_protocol_write_string (protocol,  key, error)) < 0)
          return 0;
        if ((ret = thrift_protocol_write_string (protocol,  value, error)) < 0)
          return 0;
      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_string_map (TTestThriftTestIf * iface, GHashTable ** _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0)
  {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    ThriftApplicationException *xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testStringMap", 13) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testStringMap", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_MAP)
          {
            {
              guint32 size;
              ThriftType key_type;
              ThriftType value_type;

              /* read the map begin marker */
              if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through each of the map's fields */
              guint32 i;
              for (i = 0; i < size; i++)
              {
                gchar * key63 = NULL;
                gchar * val64 = NULL;
                if (key63 != NULL)
                {
                  g_free(key63);
                  key63 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &key63, error)) < 0)
                  return 0;
                xfer += ret;
                if (val64 != NULL)
                {
                  g_free(val64);
                  val64 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &val64, error)) < 0)
                  return 0;
                xfer += ret;
                g_hash_table_insert ((GHashTable *)*_return, (gpointer) key63, (gpointer) val64);
              }

              /* read the map end marker */
              if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_string_map (TTestThriftTestIf * iface, GHashTable ** _return, const GHashTable * thing, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_string_map (iface, thing, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_string_map (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_set (TTestThriftTestIf * iface, const GHashTable * thing, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testSet", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testSet_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_SET, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      if ((ret = thrift_protocol_write_set_begin (protocol, T_I32, (gint32) g_hash_table_size ((GHashTable *) thing), error)) < 0)
        return 0;
      xfer += ret;
      GList *key_list = NULL, *iter = NULL;
      gint32* elem;
      gpointer value;
      THRIFT_UNUSED_VAR (value);

      g_hash_table_foreach ((GHashTable *) thing, thrift_hash_table_get_keys, &key_list);
      gint32* keys[g_list_length (key_list)];
      int i=0, key_count = g_list_length (key_list);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
      {
        keys[i++] = (gint32*) iter->data;
      }
      g_list_free (key_list);

      for (i=0; i<key_count; ++i)
      {
        elem = keys[i];
        value = (gpointer) g_hash_table_lookup (((GHashTable *) thing), (gpointer) elem);

        if ((ret = thrift_protocol_write_i32 (protocol, *elem, error)) < 0)
          return 0;
      }
      if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_set (TTestThriftTestIf * iface, GHashTable ** _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0)
  {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    ThriftApplicationException *xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testSet", 7) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testSet", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_SET)
          {
            {
              guint32 size;
              ThriftType element_type;
              if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through the set elements */
              guint32 i;
              for (i = 0; i < size; ++i)
              {
                gint32* _elem65 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*_elem65, error)) < 0)
                  return 0;
                xfer += ret;
                g_hash_table_insert ((GHashTable *) *_return, (gpointer) _elem65, (gpointer) 1);
              }
              if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
                return 0;
              xfer += ret;

            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_set (TTestThriftTestIf * iface, GHashTable ** _return, const GHashTable * thing, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_set (iface, thing, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_set (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_list (TTestThriftTestIf * iface, const GArray * thing, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testList", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testList_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) thing->len, error)) < 0)
        return 0;
      xfer += ret;
      guint i66;
      for (i66=0; i66<thing->len; i66++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (thing, gint32, i66)), error)) < 0)
          return 0;
      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_list (TTestThriftTestIf * iface, GArray ** _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0)
  {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    ThriftApplicationException *xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testList", 8) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testList", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              ThriftType element_type;
              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              guint32 i;
              for (i = 0; i < size; i++)
              {
                gint32* _elem67 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*_elem67, error)) < 0)
                  return 0;
                xfer += ret;
                g_array_append_vals (*_return, _elem67, 1);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;

            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_list (TTestThriftTestIf * iface, GArray ** _return, const GArray * thing, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_list (iface, thing, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_list (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_enum (TTestThriftTestIf * iface, const TTestNumberz thing, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testEnum", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testEnum_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) thing, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_enum (TTestThriftTestIf * iface, TTestNumberz* _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0)
  {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    ThriftApplicationException *xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testEnum", 8) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testEnum", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            gint32 ecast68;
            if ((ret = thrift_protocol_read_i32 (protocol, &ecast68, error)) < 0)
              return 0;
            xfer += ret;
            *_return = (TTestNumberz)ecast68;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_enum (TTestThriftTestIf * iface, TTestNumberz* _return, const TTestNumberz thing, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_enum (iface, thing, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_enum (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_typedef (TTestThriftTestIf * iface, const TTestUserId thing, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testTypedef", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testTypedef_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, thing, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_typedef (TTestThriftTestIf * iface, TTestUserId* _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0)
  {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    ThriftApplicationException *xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testTypedef", 11) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testTypedef", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I64)
          {
            if ((ret = thrift_protocol_read_i64 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_typedef (TTestThriftTestIf * iface, TTestUserId* _return, const TTestUserId thing, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_typedef (iface, thing, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_typedef (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_map_map (TTestThriftTestIf * iface, const gint32 hello, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testMapMap", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testMapMap_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "hello", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, hello, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_map_map (TTestThriftTestIf * iface, GHashTable ** _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0)
  {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    ThriftApplicationException *xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testMapMap", 10) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testMapMap", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_MAP)
          {
            {
              guint32 size;
              ThriftType key_type;
              ThriftType value_type;

              /* read the map begin marker */
              if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through each of the map's fields */
              guint32 i;
              for (i = 0; i < size; i++)
              {
                gint32* key69 = g_new (gint32, 1);
                GHashTable * val70 = g_hash_table_new (NULL, NULL);
                if ((ret = thrift_protocol_read_i32 (protocol, &*key69, error)) < 0)
                  return 0;
                xfer += ret;
                {
                  guint32 size;
                  ThriftType key_type;
                  ThriftType value_type;

                  /* read the map begin marker */
                  if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                    return 0;
                  xfer += ret;

                  /* iterate through each of the map's fields */
                  guint32 i;
                  for (i = 0; i < size; i++)
                  {
                    gint32* key71 = g_new (gint32, 1);
                    gint32* val72 = g_new (gint32, 1);
                    if ((ret = thrift_protocol_read_i32 (protocol, &*key71, error)) < 0)
                      return 0;
                    xfer += ret;
                    if ((ret = thrift_protocol_read_i32 (protocol, &*val72, error)) < 0)
                      return 0;
                    xfer += ret;
                    g_hash_table_insert ((GHashTable *)val70, (gpointer) key71, (gpointer) val72);
                  }

                  /* read the map end marker */
                  if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                    return 0;
                  xfer += ret;
                }
                g_hash_table_insert ((GHashTable *)*_return, (gpointer) key69, (gpointer) val70);
              }

              /* read the map end marker */
              if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_map_map (TTestThriftTestIf * iface, GHashTable ** _return, const gint32 hello, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_map_map (iface, hello, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_map_map (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_insanity (TTestThriftTestIf * iface, const TTestInsanity * argument, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testInsanity", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testInsanity_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "argument", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (argument), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_insanity (TTestThriftTestIf * iface, GHashTable ** _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0)
  {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    ThriftApplicationException *xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testInsanity", 12) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testInsanity", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_MAP)
          {
            {
              guint32 size;
              ThriftType key_type;
              ThriftType value_type;

              /* read the map begin marker */
              if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through each of the map's fields */
              guint32 i;
              for (i = 0; i < size; i++)
              {
                TTestUserId key73 = NULL;
                GHashTable * val74 = g_hash_table_new (NULL, NULL);
                if ((ret = thrift_protocol_read_i64 (protocol, &key73, error)) < 0)
                  return 0;
                xfer += ret;
                {
                  guint32 size;
                  ThriftType key_type;
                  ThriftType value_type;

                  /* read the map begin marker */
                  if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                    return 0;
                  xfer += ret;

                  /* iterate through each of the map's fields */
                  guint32 i;
                  for (i = 0; i < size; i++)
                  {
                    TTestNumberz key75;
                    TTestInsanity * val76 = NULL;
                    gint32 ecast77;
                    if ((ret = thrift_protocol_read_i32 (protocol, &ecast77, error)) < 0)
                      return 0;
                    xfer += ret;
                    key75 = (TTestNumberz)ecast77;
                    if ( val76 != NULL)
                    {
                      g_object_unref (val76);
                    }
                    val76 = g_object_new (T_TEST_TYPE_INSANITY, NULL);
                    if ((ret = thrift_struct_read (THRIFT_STRUCT (val76), protocol, error)) < 0)
                    {
                      g_object_unref (val76);
                      return 0;
                    }
                    xfer += ret;
                    g_hash_table_insert ((GHashTable *)val74, (gpointer) key75, (gpointer) val76);
                  }

                  /* read the map end marker */
                  if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                    return 0;
                  xfer += ret;
                }
                g_hash_table_insert ((GHashTable *)*_return, (gpointer) key73, (gpointer) val74);
              }

              /* read the map end marker */
              if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_insanity (TTestThriftTestIf * iface, GHashTable ** _return, const TTestInsanity * argument, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_insanity (iface, argument, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_insanity (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_multi (TTestThriftTestIf * iface, const gint8 arg0, const gint32 arg1, const gint64 arg2, const GHashTable * arg3, const TTestNumberz arg4, const TTestUserId arg5, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testMulti", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testMulti_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "arg0", T_BYTE, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_byte (protocol, arg0, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "arg1", T_I32, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, arg1, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "arg2", T_I64, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, arg2, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "arg3", T_MAP, 4, error)) < 0)
      return 0;
    xfer += ret;
    {
      if ((ret = thrift_protocol_write_map_begin (protocol, T_I16, T_STRING, (gint32) g_hash_table_size ((GHashTable *) arg3), error)) < 0)
        return 0;
      xfer += ret;

      GList *key_list = NULL, *iter = NULL;
      gint16* key;
      gchar * value;
      g_hash_table_foreach ((GHashTable *) arg3, thrift_hash_table_get_keys, &key_list);
      gint16* keys[g_list_length (key_list)];
      int i=0, key_count = g_list_length (key_list);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
      {
        keys[i++] = (gint16*) iter->data;
      }
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key = keys[i];
        value = (gchar *) g_hash_table_lookup (((GHashTable *) arg3), (gpointer) key);

        if ((ret = thrift_protocol_write_i16 (protocol, * key, error)) < 0)
          return 0;
        if ((ret = thrift_protocol_write_string (protocol,  value, error)) < 0)
          return 0;
      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "arg4", T_I32, 5, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) arg4, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "arg5", T_I64, 6, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, arg5, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_multi (TTestThriftTestIf * iface, TTestXtruct ** _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0)
  {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    ThriftApplicationException *xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testMulti", 9) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testMulti", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_multi (TTestThriftTestIf * iface, TTestXtruct ** _return, const gint8 arg0, const gint32 arg1, const gint64 arg2, const GHashTable * arg3, const TTestNumberz arg4, const TTestUserId arg5, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_multi (iface, arg0, arg1, arg2, arg3, arg4, arg5, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_multi (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_exception (TTestThriftTestIf * iface, const gchar * arg, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testException", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testException_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "arg", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, arg, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_exception (TTestThriftTestIf * iface, TTestXception ** err1, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0)
  {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    ThriftApplicationException *xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testException", 13) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testException", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *err1 != NULL)
            {
              g_object_unref (*err1);
            }
            *err1 = g_object_new (T_TEST_TYPE_XCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*err1), protocol, error)) < 0)
            {
              g_object_unref (*err1);
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*err1 != NULL)
  {
      g_set_error (error, T_TEST_XCEPTION_ERROR, T_TEST_XCEPTION_ERROR_CODE, "Xception");
      return FALSE;
  }
  return TRUE;
}

gboolean t_test_thrift_test_client_test_exception (TTestThriftTestIf * iface, const gchar * arg, TTestXception ** err1, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_exception (iface, arg, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_exception (iface, err1, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_multi_exception (TTestThriftTestIf * iface, const gchar * arg0, const gchar * arg1, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testMultiException", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testMultiException_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "arg0", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, arg0, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "arg1", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, arg1, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_multi_exception (TTestThriftTestIf * iface, TTestXtruct ** _return, TTestXception ** err1, TTestXception2 ** err2, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0)
  {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    ThriftApplicationException *xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testMultiException", 18) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testMultiException", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *err1 != NULL)
            {
              g_object_unref (*err1);
            }
            *err1 = g_object_new (T_TEST_TYPE_XCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*err1), protocol, error)) < 0)
            {
              g_object_unref (*err1);
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *err2 != NULL)
            {
              g_object_unref (*err2);
            }
            *err2 = g_object_new (T_TEST_TYPE_XCEPTION2, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*err2), protocol, error)) < 0)
            {
              g_object_unref (*err2);
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*err1 != NULL)
  {
      g_set_error (error, T_TEST_XCEPTION_ERROR, T_TEST_XCEPTION_ERROR_CODE, "Xception");
      return FALSE;
  }
  if (*err2 != NULL)
  {
      g_set_error (error, T_TEST_XCEPTION2_ERROR, T_TEST_XCEPTION2_ERROR_CODE, "Xception2");
      return FALSE;
  }
  return TRUE;
}

gboolean t_test_thrift_test_client_test_multi_exception (TTestThriftTestIf * iface, TTestXtruct ** _return, const gchar * arg0, const gchar * arg1, TTestXception ** err1, TTestXception2 ** err2, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_multi_exception (iface, arg0, arg1, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_multi_exception (iface, _return, err1, err2, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_oneway (TTestThriftTestIf * iface, const gint32 secondsToSleep, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testOneway", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testOneway_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "secondsToSleep", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, secondsToSleep, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_oneway (TTestThriftTestIf * iface, const gint32 secondsToSleep, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_oneway (iface, secondsToSleep, error))
    return FALSE;
  return TRUE;
}

static void
t_test_thrift_test_if_interface_init (TTestThriftTestIfInterface *iface)
{
  iface->test_void = t_test_thrift_test_client_test_void;
  iface->test_string = t_test_thrift_test_client_test_string;
  iface->test_byte = t_test_thrift_test_client_test_byte;
  iface->test_i32 = t_test_thrift_test_client_test_i32;
  iface->test_i64 = t_test_thrift_test_client_test_i64;
  iface->test_double = t_test_thrift_test_client_test_double;
  iface->test_struct = t_test_thrift_test_client_test_struct;
  iface->test_nest = t_test_thrift_test_client_test_nest;
  iface->test_map = t_test_thrift_test_client_test_map;
  iface->test_string_map = t_test_thrift_test_client_test_string_map;
  iface->test_set = t_test_thrift_test_client_test_set;
  iface->test_list = t_test_thrift_test_client_test_list;
  iface->test_enum = t_test_thrift_test_client_test_enum;
  iface->test_typedef = t_test_thrift_test_client_test_typedef;
  iface->test_map_map = t_test_thrift_test_client_test_map_map;
  iface->test_insanity = t_test_thrift_test_client_test_insanity;
  iface->test_multi = t_test_thrift_test_client_test_multi;
  iface->test_exception = t_test_thrift_test_client_test_exception;
  iface->test_multi_exception = t_test_thrift_test_client_test_multi_exception;
  iface->test_oneway = t_test_thrift_test_client_test_oneway;
}

static void
t_test_thrift_test_client_init (TTestThriftTestClient *client)
{
  client->input_protocol = NULL;
  client->output_protocol = NULL;
}

static void
t_test_thrift_test_client_class_init (TTestThriftTestClientClass *cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  GParamSpec *param_spec;

  gobject_class->set_property = t_test_thrift_test_client_set_property;
  gobject_class->get_property = t_test_thrift_test_client_get_property;

  param_spec = g_param_spec_object ("input_protocol",
                                    "input protocol (construct)",
                                    "Set the client input protocol",
                                    THRIFT_TYPE_PROTOCOL,
                                    G_PARAM_READWRITE);
  g_object_class_install_property (gobject_class,
                                   PROP_T_TEST_THRIFT_TEST_CLIENT_INPUT_PROTOCOL, param_spec);

  param_spec = g_param_spec_object ("output_protocol",
                                    "output protocol (construct)",
                                    "Set the client output protocol",
                                    THRIFT_TYPE_PROTOCOL,
                                    G_PARAM_READWRITE);
  g_object_class_install_property (gobject_class,
                                   PROP_T_TEST_THRIFT_TEST_CLIENT_OUTPUT_PROTOCOL, param_spec);
}

